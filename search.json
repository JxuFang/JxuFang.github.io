[{"title":"leetcode---反转链表","url":"/2021/09/08/leetcode---反转链表/","content":"\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/image-20210908085343660.png\" alt=\"image-20210908085343660\" style=\"zoom:67%;\" />\n\n# 1.理解题意\n\n反转链表的目标是清晰明确的，就是将一个链表（1->2->3->4->5）反转成(5->4->3->2->1)。对于反转问题，我们并不陌生，数组有反转，字符串有反转，一切皆可反转呗！但单链表的反转却有点不一样，我们只能单方向遍历链表，那么常用的**左右指针**就用不到了哦！只能根据链表自身的特点来思考其他的方法。\n\n<!--more-->\n\n# 2.思路分析\n\n有两种思路，一种是使用递归，自底向上求解；另一种是使用迭代，自顶向下求解。\n\n## 2.1 递归\n\n说到递归，那这个问题一定有一个与之对应的递推结构，换句话说就是这个问题可以由与其相同的较小规模的问题而得到（就像报数一样，最后一个人不知道自己是第几个，只能从倒数第二个人的序号中得出，倒数第二个人同样不知道自己是第几个，只能从倒数第三个人的序号中得出，...， 直到问到第一个人，他前面没有人了，知道自己的序号是1号，接着第二个人也知道了，...， 最终传到最后一个人，我们得到了一个队伍的人数）\n\n同样的，来想一想反转链表，我们要反转4个结点的链表，一下子好像做不到，那我们就先反转后三个结点，哎？一下子也做不到，那就反转后两个结点，哦可以哎！但是不要着急（就像第二个报数的人虽然知道自己前面就一个人，但他也不能把第一人给无视了啊），最后反转一个结点，最后一个结点后面没有结点了（指向null），不需要反转，直接返回就行。那再反过来想，最后一个不用反转，那就反转最后两个结点，现在就变成了（1->2->3<-4）那后三个结点不就变成反转两个结点的操作了吗？（把后两个结点看作一个整体），那太完美了，这样的话，我每次就相当于只反转两个结点，直到4个结点的时候，我就把整个链表反转了。\n\n总结一下上面这个过程，反转n个结点的链表，可以由第一个结点和已经反转好的n-1个结点的链表做反转两个结点的操作而得到。\n\n<img src=\"images/反转链表.assets/反转链表.jpg\" style=\"zoom:67%;\" />\n\n理解思路之后就来写代码吧！\n\n```java\npublic ListNode reverseList(ListNode head) {\n    if(head == null) return null;\n    //base case\n    if(head.next == null) return head;\n    //Last用来保存反转后的头结点\n    ListNode Last = reverseList(head.next);\n    //反转两个结点的操作，就是将后一个结点指向当前结点\n    head.next.next = head;\n    //反转的链表指向的rest（剩余结点只有null）\n    head.next = null;\n    return Last;\n}\n```\n\n关于上面为什么head.next指向的是null，这个在==反转链表的前n个结点==里面，我们能更好的理解。\n\n### 2.2 迭代\n\n迭代的方法就比较直接明了了，就是自顶向下，一个一个往下转变指针的方向就行了，当然其中需要几个变量来辅助我们操作链表。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8_2.jpg\" style=\"zoom:67%;\" />\n\n上面就是基本的步骤，很清晰了，不再赘述\n\n```java\npublic ListNode reverseList(ListNode head) {\n\tif(head == null) return null;\n    ListNode prev, cur, nxt;\n    prev = null; cur = nxt= head;\n    while(cur != null){\n        nxt = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = nxt;\n    }\n    return prev;\n}\n```\n\n\n\n","tags":["链表"],"categories":["leetcode"]},{"title":"leetcode---环形链表","url":"/2021/09/08/leetcode---环形链表/","content":"\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/image-20210903112445273.png\" alt=\"image-20210903112445273\" style=\"zoom:67%;\" />\n\n<!--more-->\n\n对于单链表来说，指针最后指向`null`，就说明该链表中没有环，但是如果链表中存在环，那么指针永远不会指向`null`，成了死循环。这时我们使用快慢指针来解决问题，快慢指针都是从`head`开始，`fast = fast.next.next`，`slow = slow.next`，快指针比慢指针快一倍，如果没有环，`fast`会先到`null`；如果有环，`fast`最终会超`slow`一圈和慢指针相遇。\n\n```java\nboolean hasCycle(ListNode head){\n    ListNode fast, slow;\n    fast = slow = head;\n    //链表是奇数和偶数对fast的判定条件不同\n    while(fast!=null && fast.next!=null){\n        fast = fast.next.next;\n        slow = slow.next;\n        if(fast == slow) return true;\n\t}\n    return false;\n}\n```\n\n","tags":["链表"],"categories":["leetcode"]},{"title":"leetcode---反转链表前k个结点","url":"/2021/09/08/leetcode---反转链表前k个结点/","content":"\n# 1.思路分析\n\n反转链表的前k个结点其实与反转链表差别不大，==关键点在于我们如何提前结束反转链表==，在反转链表中，我们的结束条件是什么呢？`head.next == null`，欧克，现在我们只要修改这个条件就能达到提前结束反转链表，只反转链表的前n个结点。\n\n<!--more-->\n\n# 2.具体分析\n\n## a.传入第k+1个结点\n\n在反转链表中，我们这里的k就是整个链表的长度，也就是说，其实反转链表是反转链表前n个结点的特殊情况罢了。那现在我们就要从特殊分析一般的情况，\n\n|                   | 反转结点数    | 结束条件          |\n| ----------------- | ------------- | ----------------- |\n| 反转链表          | n(链表的长度) | head.next == null |\n| 反转链表前k个结点 | k(k<=n)       | ?                 |\n\n？代表的是什么条件，让我们来想想看，n个时，head.next指向null为终止，null所在的位置不就是第n个结点的后一个吗？那一切就明白了，**通用的结束条件**应该是`head.next == ‘第k+1个结点’`，有了这个我们就能写出代码了。\n\n```java\npublic ListNode reverseK(ListNode head, ListNode kplusOne) {\n    // head.next == null才是base case ,head == null是为简洁而合并的\n    if(head == null||head.next == kplusOne) return head;\n    //递归公式\n    ListNode last = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    //转换head\n    return last;\n}\n```\n\n哎？这样写真的正确吗？\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%8F%8D%E8%BD%AC%E5%89%8Dk%E4%B8%AA.jpg\" style=\"zoom:67%;\" />\n\n通过上面这过程，我们突然发现了问题，`head.next = null`后，第k个结点后面的部分不就都丢失了吗？要怎么更改代码呢？让我们想想反转整个链表的时候，为什么要指向null，你可能会说，因为后面没有节点了啊，肯定指向null，不然还能指向啥？那再想想，如果后面有结点呢？那肯定指向后面的结点，对吧，这下我们就分析清楚啦！此时后面有结点我们不能指向null，要指向后面不反转的结点。\n\n```java\npublic ListNode reverseK(ListNode head, ListNode kplusOne) {\n    // head.next == null才是base case ,head == null是为简洁而合并的\n    if(head == null||head.next == kplusOne) return head;\n    //递归公式\n    ListNode last = reverseList(head.next);\n    //保留不反转的部分\n    ListNode rest = head.next.next;\n    head.next.next = head;\n    //指向不反转的部分\n    head.next = rest;\n    //转换head\n    return last;\n}\n```\n\n欧克，这下就正确了，但是还没有完，你要问了，题目只给了你k这个参数，该怎么办呢？\n\n## b.传入K\n\n这并不难，我前面说过，只要找到结束条件就可以了。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%8F%8D%E8%BD%ACk%E4%B8%AA_2.jpg\" style=\"zoom:67%;\" />\n\n我们使用递归就是因为可以把原问题分解为相同的子问题，原问题可以由子问题一层一层往上解决，而最终解决。我们是求前K个结点，当往下的时候，就是求下一个链表的前K-1个结点，直到K==1的时候，我们结束了，因为反转前1个结点就等于没有反转，这其实也是递归反转链表的核心思想。\n\n```java\npublic ListNode reverseK(ListNode head, int k) {\n    if(k == 1) return head;\n    //递归公式\n    ListNode last = reverseList(head.next, k-1);\n    //保留不反转的部分\n    ListNode rest = head.next.next;\n    head.next.next = head;\n    //指向不反转的部分\n    head.next = rest;\n    //转换head\n    return last;\n}\n```\n\n","tags":["链表"],"categories":["leetcode"]},{"title":"leetcode---k个一组反转链表","url":"/2021/09/08/leetcode---k个一组反转链表/","content":"![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1629383377013-c3028385-2024-4730-b0b6-a0dfa1e85403-1630981405693.png)\n\n## 1.理解题意\n\n我们需要将一个链表，按每k个为一组进行反转，不足k个的组不进行反转。\n\n<!--more-->\n\n## 2.解题步骤\n\n1. 检查当前链表够不够分组\n   - 不够分成k个，直接返回当前链表的头结点\n   - 够分成k个，则继续\n2. 反转当前链表的前K个结点\n3. 反转下一组的前K个结点\n\n上面是基本的步骤，其中还有一些细节问题，需要探究。\n\n1. 反转后怎么进行连接呢？要定义什么变量保存结点信息？\n\n这是问题的关键，因为反转后会返回==反转链表的头结点==，所以需要保存这个结点用于返回，那么返回后由谁来接收呢？需要上一个反转的链表的尾部来接收，这样才能将各自反转的链表连接在一起。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.jpg\" style=\"zoom:67%;\" />\n\n2. 怎么反转前K个结点？需要什么参数？\n\n反转链表前K个结点的方式就两种，一种是递归方式，一种是迭代方式。\n\n需要的参数取决于我们如何判断结束的条件，可以用K，也可以使用第K个结点或者是第K+1个结点，都没有问题，这和用递归方式还是迭代方式无关。\n\n关于反转前K个结点详情看\n\n代码如下：\n\n```java\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if(head == null) return null;\n        // 要有两个变量\n        //一个用来指向当前的头结点，用来在反转后指向后面的链表\n        //一个用来传递给下一组要反转的链表\n        ListNode a, b;\n        a = b = head;\n        //1.检查当前链表的结点数还够不够反转\n        for(int i = 0; i < k; i++){\n            if(b == null) return head;\n            b = b.next;\n            \n        }\n        //2.反转当前链表的前k个结点\n        ListNode newHead = reverseK(a, b);\n        //3.继续反转下一组链表\n        a.next = reverseKGroup(b, k);\n        return newHead;\n\n    }\n    //传入第K+1个结点作为结束条件（迭代）\n    public ListNode reverseK(ListNode a, ListNode b){\n        ListNode prev, cur, nxt;\n        prev = null; cur = nxt = a;\n        while(cur!=b){\n            nxt = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = nxt;\n        }\n        return prev;\n    }\n    //传入K作为结束条件（迭代）\n    public ListNode reverseK(ListNode a, int n){\n        ListNode prev, cur, nxt;\n        prev = null; cur = nxt = a;\n        while(n-- != 0){\n            nxt = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = nxt;\n        }\n        return prev;\n    }\n    //传入K作为结束条件（递归）\n    public ListNode reverseK(ListNode a, int n){\n        if(n == 1){\n            return a;\n        }\n\t\tListNode Last = reverseK(a.next, n-1);\n        ListNode tail = a.next.next;\n        a.next.next = a;\n        a.next = tail;\n        return Last;\n    }\n    //传入第K+1个结点作为结束条件（递归）\n    public ListNode reverseK(ListNode a, ListNode b){\n        if(a.next == b) return a;\n        ListNode Last = reverseK(a.next, n-1);\n        ListNode tail = a.next.next;\n        a.next.next = a;\n        a.next = tail;\n        return Last;\n    }\n}\n```\n\n"},{"title":"反射","url":"/2021/08/25/反射/","content":"\n# 反射的概述\n\n首先反射是在运行状态中才生效的，通过反射可以动态地获取一个类的所有属性和方法，并且可以对该类的任意一个对象的属性进行获取和修改，还可以调用其方法。综上其实就是让我们有了能够分析类的能力。为什么会有这样的能力呢？这就要探究一下反射的原理。\n\n<!--more-->\n\n# 反射的原理----Class类\n\n反射之所以能够有这么强大的能力，这一切都是因为有Class对象的帮助，我们也是通过获得类的Class对象，使用其方法才能得到类的信息和调用对象的方法和属性。\n\n那什么又是Class类呢？它是怎么产生的呢？\n\n在程序的运行期间，Java运行时系统始终为所有的对象维护一个运行时类型标识(*runtime type identification*)，它会跟踪每个对象所属的类。虚拟机也是利用*Runtime type identification*选择相应的方法执行（多态）。\n\n而这些信息就是通过Class类来访问的，所以我们能够通过Class对象来访问一个类的信息。Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。每一个类都有Class对象，基本类型 ( byte, char, short, int, long, float, double and boolean)有Class对象，数组有Class对象，就连关键字void也有Class对象（void.class）。\n\nClass对象有很多的方法，我们正是通过这些方法获取到一个类的成员变量、方法、构造方法、包等等信息，这就是反射为什么能分析类的原因。\n\n# 获取Class对象的四种方式\n\n1. **知道具体的类的情况下使用**\n\n```java\nClass pClass = Person.class;\n```\n\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化。**后面会介绍这几种方式的区别。**\n\n2. **通过 `Class.forName()`传入类的路径获取：**\n\n```java\nClass pClass = Class.forName(\"com.test.Person\");\n```\n\n3. **通过对象实例`instance.getClass()`获取：**\n\n```java\nPerson p = new Person();\nClass pClass = p.getClass();\n```\n\n4. **通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:**\n\n```java\nClass clazz = ClassLoader.loadClass(\"com.test.Person\");\n```\n\n通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行\n\n### 四种方式的区别\n\n**1.类名.class** 说明： JVM将使用类装载器, 将类装入内存(前提是:类还没有装入内存),不做类的初始化工作.返回Class的对象。\n\n**2.Class.forName(\"类的全限定名\")**  （注：全限定名是包名+类名）  说明：装入类,并做类的静态初始化，返回Class的对象。\n\n**3.实例对象.getClass()**  说明：对类进行静态初始化、非静态初始化；返回引用o运行时真正所指的对象(因为:子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象。\n\n**4.类加载器`xxxClassLoader.loadClass()`** 说明：同`类名.class`\n\n```java\npublic class ClassAndGetclass {\n    public static void main(String[] args) throws ClassNotFoundException {\n\n        //测试.class\n        Class testTypeClass = TestClassType.class;\n        System.out.println(\"testTypeClass---\" + testTypeClass);\n        System.out.println(\"类装入内存完毕\");\n\n        //测试Class.forName()\n        Class testTypeForName = Class.forName(\"TestClassType\");\n        System.out.println(\"testTypeForName---\" + testTypeForName);\n\n        //测试Object.getClass()\n        TestClassType testTypeGetClass = new TestClassType();\n        System.out.println(\"testTypeGetClass---\" + testTypeGetClass.getClass());\n\n        HashSet hashSet = new HashSet();\n        hashSet.add(\"s\");\n        Iterator iterator = hashSet.iterator();\n        System.out.println(iterator.getClass().getName());\n        System.out.println(Iterator.class.getName());\n\t}\n}\n\nclass TestClassType {\n//构造函数\npublic TestClassType() {\nSystem.out.println(\"----构造函数---\");\n    }\n//静态的参数初始化\nstatic {\nSystem.out.println(\"---静态的参数初始化---\");\n    }\n//非静态的参数初始化\n    {\n    System.out.println(\"----非静态的参数初始化---\");\n    }\n}\n```\n\n```cmd\ntestTypeClass---class TestClassType\n类装入内存完毕\n---静态的参数初始化---\ntestTypeForName---class TestClassType\n----非静态的参数初始化---\n----构造函数---\ntestTypeGetClass---class TestClassType\njava.util.HashMap$KeyIterator\njava.util.Iterator\n```\n\n# 反射的基本操作\n\n1.使用反射操作的类\n\n```java\npackage com.test;\npublic class Person{\n    private String name;\n    \n    public Person(){\n        name = \"Tom\";\n    }\n    public void publicMethod(String s){\n        System.out.println(\"I am learning \"+ s);\n    }\n    private void privateMethod(){\n        System.out.println(\"I am \"+name);\n    }\n}\n```\n\n2.反射的基本操作\n\n```java\npackage com.test;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, NoSuchFieldException {\n        /**\n         * 获取Person类的Class对象，并创建Person类的实例\n         */\n        Class<?> pClass = Class.forName(\"com.test.Person\");\n        Person person = (Person) pClass.getDeclaredConstructor().newInstance();\n\n        System.out.println(\"-----------------获取声明的所有方法------------------\");\n\n        /**\n         * 获取类中所有定义的方法\n         */\n        Method[] methods = pClass.getDeclaredMethods();\n        for(Method method:methods){\n            System.out.println(method.getName());\n        }\n        \n        System.out.println(\"-----------------调用public方法------------------\");\n        /**\n         * 获取指定方法并调用\n         */\n        Method publicMethod = pClass.getDeclaredMethod(\"publicMethod\", String.class);\n        publicMethod.invoke(person, \"Java\");\n        \n        System.out.println(\"-----------------修改private字段并调用private方法------------------\");\n        /**\n         * 获取指定参数并对指定参数进行修改\n         */\n        \n         Field field = pClass.getDeclaredField(\"name\");\n         //因为 name 属性是private，为了修改值，取消安全性检查\n         field.setAccessible(true);\n         field.set(person, \"JxuFang\");\n\n         /**\n          * 调用private方法\n          */\n         Method privateMethod = pClass.getDeclaredMethod(\"privateMethod\");\n         //为了调用private的方法，要取消安全性检查\n         privateMethod.setAccessible(true);\n         privateMethod.invoke(person);\n        \n    }\n}\n\n```\n\n输出：\n\n```cmd\n-----------------获取声明的所有方法------------------\nprivateMethod\npublicMethod\n-----------------调用public方法------------------\nI am learning Java\n-----------------修改private字段并调用private方法------------------\nI am JxuFang\n\n```\n\n# 反射的优缺点\n\n优点：提高了代码的灵活性\n\n缺点：在运行时有了分析类的能力，但同时也增加了安全问题（无视安全性检查）；反射的性能要比直接使用Java代码慢。\n\n# 反射的实际应用\n\n在实际开发中，基本很少会直接使用反射机制，但是并不代表反射机制没有用，恰恰相反，很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架，也是利用CGLIB 反射机制才得以实现。\n\n**JDBC连接数据库**\n\n1. 通过`Class.forName()`加载相应的数据库驱动程序（MySQL的驱动\"com.mysql.cj.jdbc.Driver\"）\n2. 通过`DriverManager`获得`Connection`（使用url,username,passwd连接数据库）\n3. `Connection`创建一个`statement`执行SQL\n\n**Spring框架的使用**\n\n通过XML配置方式来加载Bean\n\n\n\n> 参考：\n>\n> Core java volume I\n>\n> [JavaGuide/反射机制.md at master · Snailclimb/JavaGuide (github.com)](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/反射机制.md)\n>\n> [(Java基础之—反射（非常重要）_sinat_38259539的博客-CSDN博客_java 反射](https://blog.csdn.net/sinat_38259539/article/details/71799078)\n>\n> [吃透Java基础六：反射_吃透Java-CSDN博客_java的反射](https://blog.csdn.net/u013277209/article/details/102782208)","tags":["反射机制"],"categories":["Java"]},{"title":"异常","url":"/2021/08/25/异常/","content":"\n# 异常\n\n## 1、什么是异常\n\n异常是由于程序自身的错误或者受环境影响（物理因素），在程序运行期间出现了错误。\n\n## 2、异常处理的目的\n\n将程序的控制权从产生错误的地方转移到能够处理这种情况的地方（异常处理器），不让发生异常的程序出现异常终止，并且报告出是哪里出现了异常。\n\n<!--more-->\n\n## 3、异常出现的原因\n\n- 用户输入错误\n  1. 单纯的键盘输入错误\n  2. URL语法不正确\n- 设备错误\n  1. 打印机关闭或者没有纸张\n  2. 硬件出现问题\n- 物理限制\n  1. 磁盘已满\n- 代码错误\n  1. 空指针异常\n  2. 数组下标越界\n\n## 4、异常的分类\n\n```java\n/---Throwable\n    /---Error\n    /---Exception\n    \t/---IOException\n    \t\t/---EOFException\n   \t\t\t/---FileNotFoundException\n    \t\t/---MalformedURLException\n    \t\t/---UnknownHostException\n    \t/---ClassNotFoundException\n    \t/---CloneNotSupportedException\n    \t/---RuntimeException\n    \t\t/---ArihmeticException\n    \t\t/---ClassCastException\n    \t\t/---IllegalArgumentException\n    \t\t/---IllegalStateException\n    \t\t/---IndexOutOfBoundsException\n    \t\t/---NoSushElementException\n    \t\t/---NullPointerExceptioin\n//按检查（checked）分类\n/---checked(检查型)\n    /---IOException\n    /---ClassNotFoundException\n    /---CloneNotSupportedException\n/---Uncheked(非检查型)\n    /---Error\n   `/---RuntimeException\n    \n```\n\n## 5、声明异常\n\n> 一个方法必须声明所有可能抛出的检查型（checked）异常，而非检查型异常要么在你的控制之外（Error）， 要么是由从一开始就应该避免的情况所导致的（RuntimeException）。\n\n### 为什么要声明异常呢？\n\n当我们调用了别人的方法时，怎么知道这个方法有没有异常呢？这并不好判断，所以在这种情况下，编写方法的开发人员要么自己将异常捕获后处理掉，要么就是在方法的首部用`thorws`关键字声明该方法可能会抛出的检查型异常，让调用这个方法的人去处理异常。\n\n### 什么时候需要声明异常呢？\n\n- 调用了一个抛出检查型异常的方法，例如：FileInputStream的构造器\n- 检测到一个错误，并且利用`throw`语句抛出一个检查型异常\n- ...\n\n### 子类声明异常时要注意什么？\n\n如果子类中覆盖了超类的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用(范围更大)。特别地，如果父类方法没有抛出任何检查型异常，子类就不能抛出任何检查型异常。\n\n> 为什么会有这样地规定呢？\n>\n> 在多态中，我们经常会用父类的引用指向子类对象，然后调用子类重写的方法（动态绑定）。如果此时子类重写的方法抛出的异常不在父类抛出的异常之中（范围更大），那么父类就无法处理其他那些异常，从而导致错误。因此，我们才要规定子类抛出的异常范围不能超出父类的处理范围。\n>\n> ```java\n> \n> //代码演示\n> class Animal{\n>     public void eat() throws FileNotFoundException{\n>         System.out.println(\"吃食物\");\n>     }\n> }\n> class Cat extends Animal{\n>     @override\n>     public void eat() throws IOException{\n>         System.out.println(\"吃鱼\");\n>     }\n>     //Exception IOException is not compatible with throws clause in Animal.eat()\n> }\n> class ExceptionTest{\n> \tpublic static void main(String []args){\n>         testAnimalEat(new Cat());\n>     }\n>     \n>     public static void testAnimalEat(Animal a){\n>             try {\n>                 a.eat();\n>             } catch (FileNotFoundException e) {\n>                 //TODO: handle exception\n>                 e.printStackTrace();\n>             }\n>     }\n> }\n> \n> ```\n\n## 6、抛出异常\n\n### 异常抛出分为自动抛出和手动抛出\n\n**①自动抛出（隐式抛出）：**抛出的主体是JVM，在运行时遇到无法处理的异常情况\n\n**②手动抛出（显式抛出）：**在程序同使用`throw`关键字，手动将**异常实例**抛出\n\n`throw`抛出异常时，先确定要抛出什么类型的异常，然后**创建该异常类的对象**，最后`throw`该对象。\n\n## 7、自定义异常类\n\n①继承于Exception类或者其子类\n\n②两个构造器：1.无参默认构造器  2.有参包含信息（String）构造器\n\n## 8、捕获异常（try/catch）\n\n`try/catch`用于捕获异常，如果遇到我们可以处理的异常时，通常会捕获抛出的异常，并且在`catch`子句中进行处理。特殊地，如果父类没有抛出任何异常，那么子类在重写的方法中就要使用`try/catch`将抛出的异常自己捕获后处理掉。（不允许在子类的throws说明符中出现超类方法未列出的异常类）\n\n①如果`try`中出现了`catch`有的异常，则不再执行后面的代码，直接跳到`catch`中\n\n②`try`中没有出现异常，则跳过`catch`子句\n\n③`try`中出现了`catch`中没有声明的异常类型，那么这个方法就会立即退出，程序终止。\n\n","tags":["异常"],"categories":["Java"]},{"title":"HashMap","url":"/2021/08/12/HashMap/","content":"\n# HashMap\n\nHashMap实现了Map这个接口，而Map就是表示的一对键值对(key, value)的映射关系，一个key映射一个value，key不能重复，给同一个Key赋值会覆盖原来的值。Hash表是将key通过散列函数hash(x)散列到Hash表上，形成的一个映射关系。这不就是Map的一种实现吗？但是仅仅依靠散列函数是不行的，因为会存在散列冲突，而HashMap中解决冲突的方法是**链地址法**。\n\n<!--more-->\n\n### Map接口  \n\n`JDK1.7`版本\n\n```java\npublic interface Map<K,V> {\n\tV put(K key, V value);//保存键值对，如果原来有key，覆盖，返回原来的值\n    V get(Object key);// 根据键获取值，没找到，返回null\n    V remove(Object key);// 根据键删除键值对，返回key原来的值，如果不存在，返回null\n    int size();//查看键值对的个数\n    Set<K> keySet();//获取Map中键的集合\n    Set<Map.Entry<K,V>> entrySet();//获取Map中所有的键值对\n    Collection<V> values();\n    interface Entry<K, V> {\n\t\tK getKey();\n        V getValue();\n        V setValue();\n        boolean equals(Object o);\n        int hashCode();\n    }\n    ....\n}\n```\n\n> keySet(), values(), entrySet()有一个共同的特点，它们返回的都是视图，不是赋值的值，基于返回值的修改会直接修改Map自身\n\n以上就是Map的部分API，我们现在就是要使用哈希表这个数据结构来实现Map这个抽象数据结构。\n\n### HashMap的结构组成\n\n为了避免散列冲突，HashMap使用的是**链地址法**解决冲突的问题。所以采用了**数组+链表**的结构来构成hash表。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/HashMap.png\" style=\"zoom: 80%;\" />\n\n上图就展示了HashMap真正的结构，数组是由一个个`Entry<V,K>`组成的，Entry有一个next的指针去链接冲突元素，这里采用了`头插法`添加元素。**注意：这里的`null`是因为我们只给对象数组table进行了初始化，此时每个元素都是默认值null，还需要对每个entry对象进行实例化。**\n\n让我们来结合代码对HashMap的结构更深入的理解\n\n### HashMap的代码\n\n#### 1.内部组成\n\n```java\npublic class HashMap<K,V>\n    extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n{\n\n    /**\n     * The default initial capacity - MUST be a power of two.\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    /**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /**\n     * The load factor used when none specified in constructor.\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * An empty table instance to share when the table is not inflated.\n     */\n    static final Entry<?,?>[] EMPTY_TABLE = {};\n\n    /**\n     * The table, resized as necessary. Length MUST Always be a power of two.\n     */\n    transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n\n    /**\n     * The number of key-value mappings contained in this map.\n     */\n    transient int size;\n\n    /**\n     * The next size value at which to resize (capacity * load factor).\n     * @serial\n     */\n    // If table == EMPTY_TABLE then this is the initial capacity at which the\n    // table will be created when inflated.\n    int threshold;\n\n    /**\n     * The load factor for the hash table.\n     *\n     * @serial\n     */\n    final float loadFactor;\n\n    /**\n     * The number of times this HashMap has been structurally modified\n     * Structural modifications are those that change the number of mappings in\n     * the HashMap or otherwise modify its internal structure (e.g.,\n     * rehash).  This field is used to make iterators on Collection-views of\n     * the HashMap fail-fast.  (See ConcurrentModificationException).\n     */\n    transient int modCount;\n\n     static class Entry<K,V> implements Map.Entry<K,V> {\n            final K key;\n            V value;\n            Entry<K,V> next;\n            int hash;\n\n            /**\n             * Creates new entry.\n             */\n            Entry(int h, K k, V v, Entry<K,V> n) {\n                value = v;\n                next = n;\n                key = k;\n                hash = h;\n            }\n\n            public final K getKey() {\n                return key;\n            }\n\n            public final V getValue() {\n                return value;\n            }\n\n            public final V setValue(V newValue) {\n                V oldValue = value;\n                value = newValue;\n                return oldValue;\n            }\n     }\n}\n```\n\n> 上面就是JDK1.7 SE中HashMap的内部结构\n\n从源码中我们就可以看出`table`是一个`Entry`类型的数组，成为哈希表或哈希桶，其中每个元素指向一个单向链表，链表上的每个元素表示一个键值对。`table`的初始值是`EMPTY_TABLE`，一个空表。只有当添加元素的时候，才会给`table`分配空间。添加第一个元素的时候，默认分配的大小为16，此时`table`数组的大小为16，每个元素都是默认值null。只有在调用`createEntry()`方法时，才会进行实例化，后面会讲到。`table`的大小会随着键值对增加进行扩展，至于什么时候进行扩展，要取决于`threshold`，当键值对个数`size`大于等于`threshold`时就会进行扩展，而`threshold = table.length * loadFator`，装载因子`loadFactor`默认为0.75。\n\n#### 2.默认构造方法\n\n```java\npublic HashMap() {\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n}\n\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n\n    this.loadFactor = loadFactor;\n    threshold = initialCapacity;\n    init();\n}\n```\n\n#### 3.保存键值对: put()\n\n```java\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);\n    return null;\n}\n```\n\n如果是第一次保存，会先调用`inflateTable()`方法给`table`分配实际的空间，想想为什么第一次传入的是`threshold`？\n\n```java\n private void inflateTable(int toSize) {\n    // Find a power of 2 >= toSize\n    int capacity = roundUpToPowerOf2(toSize);\n\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n```\n\n接下来会检查`key`是否为`null`，如果是则会调用`putForNullKey`单独处理，会将这个key为null的，单独存储在table[0]或者table[0]所指的冲突链上。 \n\n```java\nprivate V putForNullKey(V value) {\n    //查找存不存在key为null的元素\n    for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n        if (e.key == null) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    //没有key为null的元素，则添加一个\n    addEntry(0, null, value, 0);\n    return null;\n}\n```\n\n当`key`不为`null`时，会调用`hash()`方法计算出`key`的hashcode\n\n```java\ninal int hash(Object k) {\n    /*\n    int h = hashSeed;\n    if (0 != h && k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\t*/\n    h ^= k.hashCode();\n\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看出，基于k自身的hashCode方法的返回值又进行了一些位运算，目的是为了随机和均匀性。有了hashcode之后，我们就调用`indexFor()`方法，计算hashcode应该映射到`table`的哪个位置（下标）\n\n```java\nstatic int indexFor(int h, int length) {\n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n\n对于上面的`h & (length-1)`运算进行解释，首先`table`的长度都会被限制在`non-zero power of 2`,在初始化数组的时候，有一个`roundUpToPowerOf2(toSize)`方法保证了这一点。因为当length为${2^n}$时，`h & (length-1)`就相当于是求模运算`h % length`，`&`与运算的速度要快于普通的求余运算，所以才会这样设计。\n\n> 为什么length=${2^n}$时，h & (length-1)会相当于h % length呢？\n>\n> h与${2^n}-1$进行与运算，相当于只取h二进制的后n位，因为${2^n}-1$的后n位都是1，所以与运算时，只会保留h的后n位。\n>\n> h % ${2^n}$:二进制除法相当于右位移`>>`，例如`111010>>3`,即除以$2^{3}$，右移3位变为`111`，`010`则作为余数被移除，故在做取余操作时值为`010`，即为h的n个最低位数字。\n>\n> 经过上面的解释我们就可以直到当length=${2^n}$，h & (length-1) = h % length\n\n上面我们分析得到了key被映射到table的位置，下面就是在**table[i]和table[i]的冲突链**中逐个查找是否已经有这个键了。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n\n遍历代码：\n\n```java\nfor (Entry<K,V> e = table[i]; e != null; e = e.next)\n```\n\n比较的时候，先使用hashcode进行比较，hashcode相同时，再使用equals方法进行比较\n\n```java\nif (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n```\n\n 为什么要先比较hashcode呢？因为hashcode是整数，比较的效率肯定是要比equals方法高的，如果hashcode都不相同，那么就没有必要再比较equals了。这也是为什么要在Entry中加入hashcode这个字段的原因。\n\n如果存在该key，那么我们就将这个Entry中的value替换掉，并且返回原来的那个value。\n\n如果不存在该key，那么就会调用`addEntry()`方法在计算出的散列位置上添加一个Entry\n\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\n```\n\n先要检查散列表的长度是不是大于等于`threshold`，且table[bucketIndex]是不是为null。这是什么意思呢？首先我们想一想为什么要扩容，我们主要不是位置不够了，而是怕出现哈希冲突，因为`table.length`大于`thershold`，哈希冲突出现的可能性就会很大。好，那如果我们要插入的当前位置不存在冲突，刚好就有空位置，那就没有必要去扩容了啊，直接插入不就可以了。\n\n因此只有在`size>=threshold`并且正好存在哈希冲突时，才会进行扩容。这样的设计是具有合理性的，因为每次进行扩容时都是分耗费时间的，所以能少用`resize()`方法就少用。\n\n```java\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n上面是`createEntry()`方法，采用了`头插法`进行插入。\n\n```java\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n```\n\n扩容的策略就是原来容量的`两倍`，会调用`transfer()`方法将原来哈希表中的键值对移动到newTable中的新的位置，因为哈希表的大小发生了变化，所以哈希地址(索引)要重新进行计算，所以说这是一个比较费事的操作。\n\n```java\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry<K,V> e : table) {\n        while(null != e) {\n            Entry<K,V> next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n> 注：resize一般为false.\n\n---\n\n以上保存键值对的所有代码，简单总结一下基本步骤：\n\n1. 计算键的哈希值\n2. 根据哈希值得到保存位置（取模）\n3. 插入对应位置的链表头部或更新已有值\n4. 根据需要扩展table大小\n\n下面是一个流程图，方便顺理整个流程。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/hashmap_put.jpg\" style=\"zoom:67%;\" />\n\n下面是一个时间出入操作的例子：\n\n```java\nMap<String, Integer> countMap = new HashMap<>();\ncountMap.put(\"hello\", 1);\ncountMap.put(\"world\", 3);\ncountMap.put(\"position\", 4);\n```\n\n下图是通过`new HashMap()`创建一个对象后，内存中的结构：\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/image-20210809154531667.png\" alt=\"image-20210809154531667\" style=\"zoom:33%;\" />\n\n下图是经过三次put操作后，得到的内存结构：\n\n![image-20210809154248278](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/image-20210809154248278.png)","tags":["hashmap"],"categories":["Java"]},{"title":"Git中关于LF和CRLF转换问题","url":"/2021/08/12/Git中关于LF和CRLF转换问题/","content":"\n\n\n今天本来要准备系统的学习一下git的使用，到[awesome-git](https://github.com/dictcp/awesome-git)上面找了一个教程，结果直接上来就是让我配置`core.autocrlf`和`core.safecrlf`这两个配置，然后就去搜索了这两个配置是干什么的。这才让我意识到换行在`window`、`linux`和`UNIX/Linux`上是不一样的。\n\n<!--more-->\n\n## 1.CR、LF和CRLF之间的不同\n\n* `CR: 回车(Carriage Return)`，用符号`'\\r'`表示，`ASCII`代码是**13**，十六进制代\n*  码为`0x0D`\n* `LF: 换行(Line Feed)`，使用`'\\n'`符号表示, `ASCII`代码是**10**, 十六制为`0x0A`\n* `CRLF: 回车换行`，使用`'\\r\\n'`符号表示\n## 2.三个平台上面使用的不同\n\n1. `windows`上面一直使用的是`CRLF`\n1. `UNIX/Linux`上面一直使用的是`LF`\n1. `OS X`早期的 Mac OS 使用的是`0x0D(CR)`，后来的 OS X 在更换内核后与 UNIX 保持一致了，也是用`LF`\n\n---\n\n现在三大平台上面只有`windows`是使用`CRLF`，其他都是`LF`。\n## 3.Git上提供的`LF`和`CRLF`转换的配置\n`core.autocrlf`和`core.safecrlf`是git为我们提供的转换配置和检查配置\n```bash\nAutoCRLF\n\n#提交时转换为LF，检出时转换为CRLF\ngit config --global core.autocrlf true\n\n#提交时转换为LF，检出时不转换\ngit config --global core.autocrlf input\n\n#提交检出均不转换\ngit config --global core.autocrlf false\n----------------------------------------\nSafeCRLF\n\n#拒绝提交包含混合换行符的文件\ngit config --global core.safecrlf true\n\n#允许提交包含混合换行符的文件\ngit config --global core.safecrlf false\n\n#提交包含混合换行符的文件时给出警告\ngit config --global core.safecrlf warn\n```\n如果设置为`core.autocrlf = true`的话，在window平台提交时，会将`CRLF`转为`LF`放到仓库，检出时，又会将`LF`转换为`CRLF`，那这样就会保持仓库中的一直都是`LF`。\n但是这并不是最好的做法！！\n最好的做法是从一开始就保证文件中的是`LF`，这样就不用再担心换行出现问题，而且可以设置`core.safecrlf = ture`，来帮助我们检查是否有混合换行符。\n\n\n## 4.在编辑器中设置为`LF`\n### IntelliJ IDEA\n\n1. 在`settings`中找到`Editor`，然后点击`Code Style`设置`line separator`为`Unix and OS X(\\n)`即可\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628672442482-6826ef57-eff4-452c-9eb2-002ad784a249.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n### Typora\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628672547694-8a8a0dd3-fb8d-4510-b95a-a8dfe848ce00.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n### VSCode\n在`Settings`中搜索`eol`可以看到默认是`auto`，也就是跟随系统自身。我们可以更改为`\\n`​\n当然如果是项目的话，推荐使用`.editorconfig`来配置。\n通过下面这篇文章可以学习使用怎么配`.editorconfig`\n[vscode使用editorconfig插件以及.editorconfig配置文件说明详解](https://www.jb51.net/article/185751.htm)\n​\n\n> 参考资料：\n> [git 换行符LF与CRLF转换问题 IDE的默认换行符设置为LF](https://blog.csdn.net/weixin_36836847/article/details/96115090)\n> [Git官方配置](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration)​\n\n","tags":["CRLF"],"categories":["Git"]},{"title":"GitHub+jsDelivr搭建图床","url":"/2021/08/12/GitHub+jsDelivr搭建图床/","content":"\n昨天在看的`algorithm-base`时候看到作者用的图片链接中是`https://www.jsdelivr.com/gh/...`就好奇搜索了一下，发现原来可以使用`GitHub+jsDelivr+PicGo`来搭建一个图床。本想着自己也用不到图床，反正文章都是上传到语雀上面。但是今天在leetcode做题时，想要写一个题解（还是在ppt上画了老半天的图），结果leetcode上面不能上传图片，看来就只能使用图床了。下面就简单介绍一下怎么搭建的步骤吧，网上其实已经有很多的教程了。\n\n<!--more-->\n\n## 1.在github上面创建一个新的repository\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628587571744-13b95c14-07a8-4efa-9484-d608c66ba88f.png)\n## 2.生成个人访问令牌Token\n\n1. 进入`Settings`\n1. 点击`developer settings`\n1. 点击`Personal access tokens`\n\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594005901-7269e41c-4a18-4f83-b719-756e4798ed68.png)\n然后填写相应的信息\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594227248-65152815-c84f-48c2-a3d5-a717d8fba4f8.png)\n最后生成Token，记得保存，只会保留一次\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594342407-54ea612e-58e1-4951-b93b-97e3a268dc2e.png)\n\n## 3.下载和配置PicGo\n[下载地址](https://github.com/Molunerfinn/PicGo/releases)\n\n1. 先安装插件`github-puls`，该插件是用来将图片上传到gitee或github上，比自带的github图床方便(自带的没有办法删除远程记录)\n1. 到图床设置中找到githubpuls先进行配置\n\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594748299-f0c5052e-6db2-4f44-ac3e-8bc129e2c09f.png)\n> repo: 就是刚才创建的github仓库\n> branch: 分支，默认时master，也可以是其他的分支\n> token: 刚才从github上生成的\n> path: 仓库下的路径（需要现在仓库中创建相应的文件夹）**要清楚文件夹和文件的路径区别**​\n> customUrl: 自定义路径，这里我们使用jsDelivr免费的CND为我们进行加速\n> orgin: 所要上传的地址，这里我们是github\n\njsDelivr的格式：`https://cdn.jsdelivr.net/gh/user/repo@version/file`\n官网上都有介绍: [jsDelivr](https://www.jsdelivr.com/)\n![image.png](images/GitHub+jsDelivr搭建图床.assets/1628595754598-812ae538-a6ad-4bf2-bce2-41790e879e01.png)\n\n3. 配置完成后就可以进行上传了\n\n在上传区选择githubPuls就可以上传\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628595615287-57877410-929b-4ae1-97b1-c3effc01f1f2.png)\n\n> 某分支和版本号大小不能超过50M会直接被jsDelivr屏蔽。所以单某个分支接近临界值，换分支继续就得了。\n\n> 参考博客：\n> [PicGo搭建github图床](https://jxiaow.gitee.io/posts/2513fba4/)\n> [jsdriver-github打造永久免费加速的图床](http://blog.wya1.com/article/636697030/details/21238)\n> [教你如何使用github+jsDelivr搭建免费图床](https://www.cnblogs.com/starry-skys/p/13905766.html)\n\n","tags":["图床"],"categories":["其他"]},{"title":"tensorflow中的asix理解","url":"/2020/12/13/2020-12-13-tensorflow中的asix理解/","content":"\n## 解释axis\n\n**axis是跟shape相关的**，比如说shape = [a, b, c, d]，那么`asix = 0`，就是指相关的操作是跟a这个维度有关的，`asix = 1`，就是指相关的操作是跟b这个维度有关，其他的就以此类推。其中有一个特殊的`asix = -1`，这是指跟d这个维度有关。(python中-1指最后一个元素)。\n<!--more-->\n下面让我们来看几个跟axis有关的函数\n\n## 例子\n\n### tf.reduce_mean\n```python\ntf.reduce_mean(input_tensor,axis=None,keepdims=None,\nname=None,reduction_indices=None,keep_dims=None)\n```\n\n这个函数经常用来求平均值，对于其中的axis参数就是指定对shape中哪一维进行求平均值（如果`axis=None`，那么就是对所有维度都求其平均值，最后返回一个single element）\n\n让我们来看一个例子：\n\n```python\na = tf.constant([[1., 1., 1.], [2., 2., 2.]])\nb = tf.reduce_mean(a, axis=None, keep_dims=True)\nc = tf.reduce_mean(a, axis=0, keep_dims=True)\nd = tf.reduce_meam(a, axis=1, keep_dims=True)\nwith tf.Session() as sess:\n    print(\"shape: \"+ str(a.shape))# shape: (2,3)\n    print(b.eval())# [[1.5]]\n    print(c.eval())# [[1.5 1.5 1.5]]\n    print(d.eval())# [[1.],[2.]]\n```\n\n通过上面的例子，可以看出当`axis=None`时，每一个维度依次都会求平均值；当`axis=0`时，就对行方向上的元素进行求平均值；当`axis=0`时，就对列方向上的元素进行求平均值。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/axis%E8%A7%A3%E9%87%8A_1.png\" style=\"zoom:50%;\" />\n\n### tf.split\n```python\ntf.split(\n    value, num_or_size_splits, axis=0, num=None, name='split'\n)\n```\n\n这个函数是用来对数据进行切割的，它会沿着第axis阶对value进行切割，切割成`num_or_size_splits`份。\n\n让我们来看个例子：\n\n```python\n# 'value' is a tensor with shape [2, 6]\n# Split 'value' into 3 tensors with sizes [1, 2, 3] along dimension 1\nvalue = tf.constant([[1,1,1,1,1,1],\n                    [2,2,2,2,2,2]])\nsplit0, split1, split2 = tf.split(value, num_or_size_splits=[1, 2, 3], axis=1)\nwith tf.Session() as sess:\n    print(split0.eval())\n    print(split1.eval())\n    print(split2.eval())\nprint(\"-------------\")\n# Split 'value' into 3 tensors along dimension 1\nsplit4, split5 = tf.split(value,num_or_size_splits=2, axis=0)\nwith tf.Session() as sess:\n    print(split4.eval())\n    print(split5.eval())\n# [[1]\n# [2]]\n# [[1 1]\n# [2 2]]\n# [[1 1 1]\n# [2 2 2]] \n# -------------\n# [[1 1 1 1 1 1]]\n# [[2 2 2 2 2 2]]\n```\n\n通过上面的例子可以看出，当`axis=0`时，就会沿着第0阶，也就是沿着纵方向将数据切割；当`axis=1`时，就会沿着第1阶，也就是沿着横方向将数据切割。\n\n## 总结\n\n综上，我们其实可以看出，axis在shape中代表哪一维度，那么就会对沿该维度方向上的数据进行求和、求平均和分割等操作。其中axis代表的维度大小会因操作而有所改变，但是其他维度的大小却并不会改变。","tags":["axis理解"],"categories":["tensorflow"]},{"title":"(计算机网络)TCP运输连接的建立和释放","url":"/2020/12/02/2020-12-2-计算机网络-tcp的连接和释放/","content":"## tcp的三次握手和四次握手\nTCP是面向连接的运输，这是因为在一个应用进程可以开始向另一个应用程序进程发送数据之前，这两个进程必须先互相“握手”，也就是互相发送某些特殊的报文段，以确认互相可以收到彼此发送的数据和建立确保数据传输的参数。\n<!--more-->\n\nTCP的这种“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，因为TCP协议旨在端系统中运行，而不再中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态，中间路由器对TCP连接完全视而不见，它们看到的是数据报而不是连接。另外TCP连接是**点对点**的，即单个发送方和单个接受方之间的连接。\n\n那么下面让我们看看TCP连接是如何建立的。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg\" style=\"zoom:67%;\" />\n\n发起连接的进程被称为**客户进程**，而另一个进程被称为**服务器进程**。假设主机A运行TCP客户进程，主机B运行TCP服务器进程，开始两端的TCP进程都处于CLOSRED状态。\n\n1. 主机B的TCP服务器进程先创建传输控制块TCB，此时处于LISTEN状态，等待客户的连接请求。\n2. 主机A的TCP客户进程也会先创建传输控制块TCB，当想要建立连接时，客户端的TCP先会向服务器端发送一个连接请求报文段(SYN 报文段)，这个报文段不包含应用层数据，但是会将报文段首部的标志位SYN=1，然后随机选择一个初始序号seq=x，此时TCP客户进程进入SYN-SENT状态。\n3. 主机B收到连接请求报文段，为该TCP连接分配TCP缓存和变量，并向客户进程发送允许连接报文段(SYNACK 报文段)，这个报文段也不包含应用层数据，但是会将报文段首部的标志位SYN=1，ACK=1，(确认号)ack=x+1,，然后选择一个初始序号seq = y，此时TCP服务器进程进入SYN-RCVD状态。\n4. 主机A收到允许连接请求报文段，为该TCP连接分配缓存和变量，并向服务器进程发送一个报文段，这个报文段是对服务器允许连接的报文段的确认。该报文段是可以携带应用层数据的，并且报文段首部的标志位SYN=0，ACK=1，ack=y+1，seq=x+1，此时TCP客户进程进入ESTABLISHED(已建立连接)状态。\n5. 服务器进程收到客户进程的确认报文段后，进入ESTABLISHED状态。\n\n至此两个主机的连接建立完成，客户和服务器主机就可以互相发送包括数据的报文段了，以后的每一个报文段的SYN都会被设置为0。\n\n天下无不散之宴席，TCP连接也是如此，参与一个连接的两个进程，任意一个都可以终止该连接，连接结束之后主机中参与连接的“资源”--缓存和变量都会释放。那再让我们看看TCP连接时如何释放的。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg\" style=\"zoom:80%;\" />\n\n此时客户进程和服务器进程都是处于ESTABLISHED状态。\n\n1. 当主机A的TCP客户进程要结束连接时，先向主机B的服务器进程发送连接释放报文段，这个报文段首部的标志位FIN=1，seq=u（这里的序号是已发送数据的最后一个字节的序号加一），并停止发送数据，此时客户进程进入FIN-WAIT-1状态。\n2. 当主机B的TCP服务器进程收到连接释放报文段后，立即发送确认报文段，这个报文段首部的标志位ACK=1，ack=u+1，seq=v，但是可以继续发送未发送完的数据，此时服务器进程进入CLOSE-WAIT状态。\n3. 当主机A的TCP客户进程收到了确认报文段后，进入FIN-WAIT-2状态，等待主机B发送的连接释放报文段。\n4. 当主机B没有要向A发送的数据后，其服务器进程就会通知TCP发送连接释放报文段，这个报文段首部的标志位FIN=1，ACK=1，seq=w，ack=u+1,这时服务器进程进入LAST-ACK状态。\n5. 当主机A收到来自主机B的连接释放报文段后，理解发送确认报文段，这个报文段首部的标志位ACK=1，seq=u+1，ack=w+1，此时TCP客户进程进入TIME-WAIT状态，等待2MSL的时间后进入CLOSED状态，如果再次收到来自主机B的连接释放报文段，重新发送确认报文段，然后再等待2MSL，注意在TIME-WAIT状态时，连接并没有释放掉。\n6. 当主机B收到主机A的确认报文段后，立即进入CLOSED状态。如果超时则重新发送连接释放报文段。\n\n至此TCP连接的释放也就完成了，在整个TCP连接的建立和释放中，连接建立时一共发送了三个报文段，因此被称为“三次握手”，而连接释放时一共发送了四个报文段，因而被称为“四次握手”。\n\n有关序号(seq)和确认号(ack)：\n\n- **序号**是TCP报文段的一个字段，TCP把数据看成无结构、有序的字节流，而序号就是建立在这样的字节流上的，不是建立在传送的报文段的序列上的。因此一个报文段的序号就是该报文段首字节的字节流编号。举一个例子，假如数据流是由一个500 000字节的文件组成，其MSS的大小为1000字节，数据流的首字节的标号为0，那么TCP为该数据流构建500个报文段，其中第一个报文段的序号为0，第二个报文段的序号为1000，以此类推。\n- **确认号**是也是TCP报文段的一个字段，TCP是全双工的，当主机A给主机B发送数据的同时，也可能会收到来自主机B的数据，**主机A填入报文段中的确认号是希望从主机B收到下一个字节的序号。**假设主机A收到了来自主机B的编号为0~535的所有字节，同时主机A有准备给主机B发送一个报文段，那么就会在给主机B发送的这个报文段中填上确认号534。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E6%95%B0%E6%8D%AE%E6%B5%81.jpg\" style=\"zoom:67%;\" />\n\n> 文章参考自《计算机网络》第七版--谢希仁——5.9.2 TCP连接释放\n>                     《计算机网络：自顶向下方法》7th——3.5.6TCP连接管理","tags":["tcp"],"categories":["计算机网络"]},{"title":"有关二项分布和二项式系数","url":"/2020/08/31/2020-8-31-Binomial/","content":"`来源`：algorithms4一书中的**Exercises1.1.27**\n\n## 二项式系数（binomail coeff）\n\n### 基本概念\n\n​        在数学上，二项式系数是二项式定理中各项的系数。一般而言吗，二项式系数有两个非负整数`n`和`k`为参数决定，写作 $n \\choose k$，定义为$(1+x)^{n}$的 多项式展开式中，$x^{k}$项的系数，因此一定是非负整数。如果将二项式系数$\\left(\\begin{array}{l}n \\\\ 0\\end{array}\\right),\\left(\\begin{array}{l}n \\\\ 1\\end{array}\\right), \\ldots,\\left(\\begin{array}{l}n \\\\ n\\end{array}\\right)$写成一行，再依照$n=0,1,2, \\ldots$顺序由上往下排列，则构成**帕斯卡三角形**或者**杨辉三角**。\n\n<!--more-->\n\n-----------来源自[维基百科]([https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%BC%8F%E4%BF%82%E6%95%B8](https://zh.wikipedia.org/wiki/二項式係數))\n\n### 递推公式\n\n$$\n\\begin{array}{l}\nC(n, k)=C(n-1, k-1)+C(n-1, k) \\\\\nC(n, 0)=C(n, n)=1\n\\end{array}\n$$\n\n根据上面的递推公式，发现可以把原问题分解成两个相同的子问题，并且结合初始条件后，可以使用递归的方法求解二项式系数。\n\n> **递归**是指一种通过重复将问题分解为同类的子问题而解决问题的方法。在递归代码中最重要的两个点：递推公式和结束条件。递推公式用于将问题分解为子问题，结束条件是最简子问题的答案。\n\n### 代码实现\n\n- **Optimal Substructure** (Following is a simple recursive implementation that simply follows the recursive structure mentioned above.)\n\n  ```java\n  // Returns value of Binomial \n  \t// Coefficient C(n, k) \n  \tstatic int binomialCoeff(int n, int k) \n  \t{ \n  \t\n  \t\t// Base Cases \n  \t\tif (k == 0 || k == n) \n  \t\t\treturn 1; \n  \t\t\n  \t\t// Recur \n  \t\treturn binomialCoeff(n - 1, k - 1) + \n  \t\t\t\t\tbinomialCoeff(n - 1, k); \n  \t} \n  \t\n  ```\n\n  \n\n- **Overlapping Subproblems** (DP based implementation)\n\n  ```java\n  // Returns value of Binomial Coefficient C(n, k) \n      static int binomialCoeff(int n, int k) \n      { \n      int C[][] = new int[n+1][k+1]; \n      int i, j; \n        \n          // Calculate  value of Binomial Coefficient in bottom up manner \n      for (i = 0; i <= n; i++) \n      { \n          for (j = 0; j <= min(i, k); j++) \n          { \n              // Base Cases \n              if (j == 0 || j == i) \n                  C[i][j] = 1; \n         \n              // Calculate value using previously stored values \n              else\n                  C[i][j] = C[i-1][j-1] + C[i-1][j]; \n            } \n       } \n         \n      return C[n][k]; \n      } \n    \n      // A utility function to return minimum of two integers \n      static int min(int a, int b) \n      { \n      return (a<b)? a: b;  \n      } \n  ```\n  **对于基于DP实现的方法**：为什么能使用DP方法实现呢？因为我们发现实际上在递归调用的时候，很多函数是会被重复调用的（如下图），但是递归时并不会储存前面已经计算出的结果，而是会重新计算，这样的情况怎么才能避免呢？那只要将已经计算过的值储存下来，以后再使用的时候就不用再计算了。而二项式系数这个问题具有动态规划的两个特点，分别就是[Optimal substructure](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)和[Overlapping subproblem](https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/)，因此我们可以使用DP方法来实现计算二项式系数这个问题。<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1381c0000d9140e5bc0f9\" alt=\"recursion tree\" style=\"zoom: 67%;\" />\n\n  **关于代码**：为什么数组大小是`int[n+1][k+1]`？因为要计算`C[n][k]`需要从最底层的`C[0][0]`一层一层计算到`C[n][k]`，而每一层所要知道的值是`C[*][j]`且`j<=min(i,k)`，所以我们所需的二维数组大小至少应该是N行K列，才足以储存我们计算得到的值。为什么第二层循环中`j<=min(i,k)`而不是`j<=k`？首先`j<=k`我们应该都是可以理解的，因为要遍历整个二维数组，但是对于二项式系数还有一个限制条件就是`0<=j<=i`（想一想杨辉三角其实很容易就得出），而i与k得大小不定的，所以我们要取最小的一个。\n\n> 参考自 GeeksforGeeks---[Binomial Coefficient](https://www.geeksforgeeks.org/binomial-coefficient-dp-9/)\n>\n\n\n\n## 二项分布（Binomial distribution）\n\n### 基本概念\n\n​        二项分布是*n*个独立的成功/失败实验中成功的次数的离散概率分布，其中每次试验的成功概率为*p*。一般地，如果随机变量*X*服从参数为n和*p*的二项分布，我们记$X \\sim b(n, p)$或$X \\sim B(n, p)$。n次试验中正好得到k次成功的概率由概率质量函数给出：\n$$\nf(k, n, p)=\\operatorname{Pr}(X=k)=\\left(\\begin{array}{l}\nn \\\\\nk\n\\end{array}\\right) p^{k}(1-p)^{n-k}\n$$\n对于$k=0,1,2, \\ldots, n$，其中$\\left(\\begin{array}{l}n \\\\ k\\end{array}\\right)$是二项式系数，又记为$C(n, k)$，$C_{n}^{k}$\n\n-----------来源自[维基百科]([https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%88%86%E4%BD%88](https://zh.wikipedia.org/wiki/二項分佈))\n\n### 递归公式\n\n$$\n\\begin{aligned}\nC_{n}^{k}p^{k}(1-p)^{n-k}&=(C_{n-1}^{k}+C_{n-1}^{k-1})p^{k}(1-p)^{n-k}\\\\\n&=C_{n-1}^{k}p^{k}(1-p)^{n-k}+C_{n-1}^{k-1}p^{k}(1-p)^{n-k}\\\\\n&=(1-p)C_{n-1}^{k}p^{k}(1-p)^{n-k-1}+pC_{n-1}^{k-1}p^{k-1}(1-p)^{n-k}\\\\\nC_{0}^{0}p^{0}(1-p)^{0}=1\n\\end{aligned}\n$$\n\n### 代码实现\n\n- **recursive implementation** \n\n  ```java\n  public static double binomial1(int N, int k, double p) {\n          \n          if (N == 0 && k == 0) return 1.0; \n          if (N < 0 || k < 0) return 0.0;\n          \n          return (1.0 - p) * binomial1(N - 1, k, p) + p * binomial1(N - 1, k - 1, p);\n      }\n  ```\n\n  **关于代码**：对于计算二项分布的结束条件为什么和计算二项式系数不同？因为二项分布返回的分布的值，不仅仅是二项式系数，而计算二项式系数时的结束条件，是我们已经清楚地知道当`k == 0 || k == n`二项式系数的值肯定是1，但是计算二项分布时，我们知道的唯一条件就是当`N == 0 && k == 0`分布的值为1，而当`N < 0 || k < 0`时连二项式系数都不存在，那么返回的分布的值为0是显而易见的。虽然计算二项分布时不能用计算二项式系数的结束条件，但是反过来，计算二项式系数时却可以使用计算二项分布的结束条件。由此可见，`if (N == 0 && k == 0) return 1.0;`和`if (N < 0 || k < 0) return 0.0;`这两个条件是更为一般的条件。\n\n- **DP based implementation**\n\n  ```java\n  \tstatic double binomial2(int N, int k, double p) {\n          double[][] b = new double[N+1][k+1];\n  \n          // base cases\n          for (int i = 0; i <= N; i++)\n              b[i][0] = Math.pow(1.0 - p, i);\n          b[0][0] = 1.0;\n  \n          // recursive formula\n          for (int i = 1; i <= N; i++) {\n              for (int j = 1; j <= min(i, k); j++) {\n                  b[i][j] = p * b[i-1][j-1] + (1.0 - p) *b[i-1][j];\n              }\n          }\n          \n          return b[N][k];\n      }\n  \n      public static int min(int a, int b){\n          return (a<b)?a:b;\n      }\n  ```\n\n  **关于代码**：二项分布同样是可以用动态规划的方法解决，主要就是使用数组将计算过的分布值储存下来，以避免重复计算。因为数组的下标是没有负的，我们就失去了一个在递归方法中的一个条件，但是我们明确地知道当`k = 0`时分布的值为`Math.pow(1.0 - p, i)`，因此可以提前计算出这些分布值，再由已知分布值计算其他的分布值。那有人就要问了，为什么我们不用计算出`k = n`时分布的值`Math.pow(p, i)`？举个例子，当我们要求`b[5][5]`时，我们需要知道`b[4][4]`和`b[4][5]`，`b[4][5]`实际上是不存在的，所以它在数组中的值是0，那我们就知道了`b[5][5] = p*b[4][4]`，而`b[4][4]`当然可以`b[3][3]`求得，以此类推，`b[5][5]`也就可以求出了。还有我们能用到`b[i][i]`的时候也很少，所以没有必要取单独计算。\n\n","tags":["二项式"],"categories":["Math"]},{"title":"问题：多段图求s到t的最小成本路径","url":"/2020/08/11/2020-4-24-多段图/","content":"\n## 什么是多端图\n\n- 多段图是一个带权有向图并且无环\n- 有且仅有一个起始点（原点source）和一个终止节点（汇点target）\n- 它有n个阶段，每个阶段由特定的几个结点构成\n- 每个结点的所有结点都只能指向下一个相邻的阶段，阶段之间不能越界\n<!-- more -->\n### 多段图\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%A4%9A%E6%AE%B5%E5%9B%BE.jpg\" style=\"zoom:80%;\" />\n\n> 图中的节点被划分程k≥2个不相交的集合Vi，1≤i≤k，其中V1和Vk分别只有一个结点 s（源点）和t（汇点）。\n\n``这个问题用动态规划的方法解决，分别有向前处理和向后处理两种思路``\n\n#### 数据结构\n\n- cost数组：该数组用于记录以某个结点为起点，到终点t的最短路径长度值。\n- d数组：该数组用于记录最短路径中出现的所有结点，下标表示结点的编号，数组值表示i的后继结点标号。\n  \n##### 多段图向前处理的算法\n\n>流程\n\n1. 从最后一个结点（汇点）开始，从后向前，依次计算每个结点的cost值和d值。\n2. 直到计算完第一个结点（源点）后，即可根据d数组得到最短路径。\n\n>思路：   \n>从最后一层的汇点开始，找当前这一层每个结点到汇点的最短路径，并且使用cost数组储存最短路径长度值，以便让上一层的结点计算最短路径长度值时不在重复计算，同时使用d数组储存该结点到下一层最短路径上的那个结点。这就体现了动态规划的思想，使用空间换取时间，储存现阶段的值，让下一阶段不在重复计算。   \n> **结合下面的算法执行过程更容易理解**\n\n>算法执行过程：\n>当前结点i到汇点t的最短路径长度cost[i] = min{结点i到下一层结点j的路径长度 + 下一层节点j到汇点t的最短路径长度cost[j]}(min是取最小的一个)\n\n- V5：cost[12] = 0\n- V4：cost[11] = min{ c(11,12)+cost[12] } = min{1 + 0} = 1 , **d[11] = 12**\n- V4：cost[10] = min{ c(10,12)+cost[12] } = min{2 + 0} = 2 , **d[10] = 12**\n- V4：cost[9] = min{ c(9,12)+cost[12] } = min{4 + 0} = 4 , **d[9] = 12**\n- V3：cost[8] = min{ c(8,11)+cost[11], c(8,10)+cost[10]} = min{7,7} = 7 , **d[8] = 10**\n- V3：cost[7] = min{ c(7,10)+cost[10], c(7,9)+cost[9]} = min{5,8} = 5 , **d[7] = 10**\n- V3：cost[6] = min{ c(6,10)+cost[10], c(6,9)+cost[9]} = min{7,10} = 7 , **d[6] = 10**\n- V2：cost[5] = min{ c(5,8)+cost[8], c(5,7)+cost[7]} = min{15,16} = 15 , **d[5] = 8**\n- V2：cost[4] = min{ c(4,8)+cost[8] } = min{11+7} = 18 , **d[4] = 8**\n- V2：cost[3] = min{ c(3,7)+cost[7], c(3,6)+cost[6]} = min{12,9} = 9 , **d[3] = 6**\n- V2：cost[2] = min{ c(2,8)+cost[8], c(2,7)+cost[7], c(2,6)+cost[6]} = min{8,7,11} = 7 , **d[2] = 7**\n- V1：cost[1] = min{ c(1,5)+cost[5], c(1,4)+cost[4], c(1,3)+cost[3], c(1,2)+cost[2]} = min{17,22,16,15} = 15 , **d[1] = 2**\n\n>根据上面的计算我们可以得出从源点s到汇点t的最短路径长度为15，同时可以通过数组d[1]依次向后推得到最短路径1->2->7->10->12;\n\n![](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/QQ%E5%9B%BE%E7%89%8720200424202235.png)\n\n##### 算法描述\n\n```c\ncost[n] = 0;\nfor i=n-1 downto 1 do\n{\n    寻找结点r,满足<i,r>∈E(有向边)且使c(i,r) + cost[r]最小\n    cost[i] = c(i,r) + cost[r];\n    d[i] = r;\n}\n//根据数组d求最短路径\np[1] = 1; p[k] = n;\nfor i=2 to k-1 do\np[i]=d[p[i-1]];\nend\n```\n\n------\n\n**多段图向后处理的算法其实和向前处理的算法思路基本上是一致的,有关具体的代码以后会补充上。**\n\n注:本文章参考了多篇文章和老师上课所讲的笔记,我都会把链接发在下面,有需要的人可以看看。\n>[参考博客1](https://blog.csdn.net/u010425776/article/details/70053196) \n>[参考博客2](https://blog.csdn.net/ncepuzhuang/article/details/8923790)\n>[老师的笔记](https://ae01.alicdn.com/kf/U74d5dbb2143b436db8df7f1d2c37678ck.jpg)","tags":["动态规划"],"categories":["算法"]},{"title":"使用Matlab解决简单的线性规划问题","url":"/2020/08/11/2020-3-7-linearPrograming/","content":"\n> 如果你还没有Matlab，那么可以在[这里](https://www.macxin.com/archives/10739.html)安装！！！\n\n## 什么是线性规划？\n\n**线性规划**是一个在数学模型中能够得到最好结果的方法，而这个数学模型是用线性关系表示的。更正式地说，线性规化是一种优化线性目标函数的技术，这种技术受线性等式和线性不等式的约束。\n<!-- more -->\n## 线性规划能用来做什么?\n\n在运筹学的领域，线性规划使用来得到最优解的。它可以让我们在一个问题的所有限制或约束条件中找到最好、最经济的解决办法。\n\n### 问题引入\n\n> 某机床生产甲、乙两种机床，每台销售后的利润分别为4千元、3千元。生产甲机床需要A，B机器加工，加工时间分别为每台2h和1h；生产乙机床需要A,B,C三种机器加工加工时间为每台各1h。若每天可用于加工的机器时数分别为A机器10h、B机器8h、C机器7h，问该生产甲、乙机床各几台，才能是总利润最大？\n\n根据问题，我们假设需要生产甲机床$x_1$台，乙机床$x_2$台才能使利润最大。\n> max z = 4$x_{1}$ + 3$x_2$  \n> 2$x_1$ + $x_2$ $\\leq$ 10  \n> $x_1$ + $x_2$  $\\leq$ 8  \n> $x_1$ $\\leq$ 7  \n> $x_1$ ,$x_2$ $\\geq$ 0\n\n以上就是根据题意得出的目标函数和约束条件。  \n\n**线性规划的图解法**  \n图解法可以说是使得问题更加的清晰和明了，正如数学教授华罗庚说的“数无形时少直觉，形少数时难入微”，对于简单的线性规划问题，图解法是一种好的解决办法。\n\n![](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/picture1.png)\n``给定一个固定z值，就会有一条相应的目标直线，而我们需要的是最大利润，那么就是希望z的值最大，当目标直线和可行域（阴影部分）某个点相交时使得z的值最大，那么这个点就是我们想要得到的可行解(2,6)``\n\n#### 下面就是我们今天要说的 *使用Matlab来求解线性规划问题*\n\n**linprog**是我们在matlab中解决线性规划问题所要用的函数，其中有几个重要的参数：\n>**A** 是一个线性不等式约束的M$\\times$N系数矩阵，其中M是不等式的数量，N是自变量的数量。\n>\n>**b** 是一个具有M个元素的列向量\n>\n>这样的不等式应该是 A*x $\\leq$ b的形式。  \n>For example：  \n>$x_1$ + 2$x_2$ $\\leq$ 10  \n>3$x_1$ + 4$x_2$ $\\leq$ 20  \n>5$x_1$ + 6$x_2$ $\\leq$ 30  \n>$\\Downarrow$  \n>A = [1,2;3,4;5,6];  \n>b = [10;20;30];\n>\n>**Aeq** 是一个线性等式约束的M$\\times$N系数矩阵，其中M是不等式的数量，N是自变量>的数量。  \n>**beq** 是一个具有M个元素的列向量  \n>For example：  \n>$x_1$ + 2$x_2$ +3$x_3$ = 10  \n>2$x_1$ + 4$x_2$ +$x_3$= 20  \n>$\\Downarrow$  \n>Aeq = [1,2,3;2,4,1];  \n>beq = [10;20];  \n>\n>**lb** 是变量的下限（Lower bounds）  \n>**ub** 是变量的上限（upper bounds）  \n>For example：  \n>-1 $\\leq$ $x_1$ $\\leq$ 1.5  \n>-0.5 $\\leq$ $x_2$ $\\leq$ 1.25  \n>$\\Downarrow$  \n>lb = [-1,-0.5];  \n>ub = [1.5,1.25];  \n>其中**无穷的表示方法**为 **inf**  \n>**f** 是目标函数的系数向量  \nExample：f = [1,3,5,-6];\n\nlinprog的一些语法（Syntax）:\n\n1. x = linprog(f,A,b)\n2. x = linprog(f,A,b,Aeq,beq)\n3. x = linprog(f,A,b,Aeq,beq,lb,ub)\n\n**线性规划问题标准的矩阵表达形式为:**\n> min $C^T$X\n> AX = b\n> X $\\geq$ 0\n\n**Matlab代码块：**\n\n```matlab\n>> A = [2,1;1,1];\n>> b = [10;8];\n>> Aeq = [];\n>> beq = [];\n>> lb = [0,0];\n>> ub = [7,inf];\n>> f = [-4,-3];\n>> x = linprog(f,A,b,Aeq,beq,lb,ub)\n\nOptimal solution found.\n\n\nx =\n\n     2\n     6\n\n```\n\n**注意**: 目标函数根据标准形式应该由最大（max）通过目标函数的标准化化为最小（min），f = [-4,-3]而不是[4,3]. 如果没有不等式A*x $\\leq$ b的存在，则令A = [],b = [];若没有等式约束，则令Aeq = [],beq = []。\n\n***\n**以上就是我使用matlab解决线性规划问题的方法，当然我并没有将Matlab中求解线性规划问题的所有东西都讲到，我在这只是起到一个抛砖引玉的作用，如果想要学习更多的方法请你也来动动手，更加深入的学习吧！！**\n\n[Matlab中文文档](https://ww2.mathworks.cn/help/matlab/ref/doc.html)中有更多关于Matlab的使用方法。\n","tags":["matlab"],"categories":["Math"]}]