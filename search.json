[{"title":"MySQL基础知识","url":"/2021/08/12/MySQL基础知识/","content":"\n# 1、初识MySQL\n\n## 1.1、什么是数据库\n\n**概念**：长期存放在计算机中，有组织，可共享的大量数据的集合，是一个数据的\"仓库\"(**通常是一个文件或者一组文件**)\n\n**作用**： 保存数据，并能安全的管理数据\n\n<!--more-->\n\n## 1.2、数据库的分类\n\n- 关系型数据库（SQL）\n  - MySQL，Oracle，SQL Server，SQLite，DB2...\n  - 关系型数据库通过外键关联来建立表与表之间的关系\n- 非关系型数据库（NOSQL）\n  - Redis，MongoDB...\n  - 非关系型数据库通常指数据一对象的形式存储在数据库中，而对象之间的关系通过每个对象的自身的属性来决定。\n\n## 1.3、MySQL的安装步骤\n\n1、下载后得到zip压缩包.\n\n2、解压到自己想要安装到的目录，本人解压到的是D:\\Environment\\mysql-5.7.19\n\n3、添加环境变量：我的电脑->属性->高级->环境变量\n\n```\n选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹\n```\n\n4、编辑 my.ini 文件 ,注意替换路径位置\n\n```\n[mysqld]\nbasedir=D:\\Program Files\\mysql-5.7\\\ndatadir=D:\\Program Files\\mysql-5.7\\data\\\nport=3306\nskip-grant-tables\n```\n\n5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld –install (安装mysql)\n\n6、再输入  mysqld --initialize-insecure --user=mysql 初始化数据文件\n\n7、然后再次启动mysql 然后用命令 mysql –u root –p 进入mysql管理界面（密码可为空）\n\n8、进入界面后更改root密码\n\n```sql\nupdate mysql.user setauthentication_string=password('123456') whereuser='root' and Host = 'localhost';\n```\n\n9、刷新权限\n\n```sql\nflush privileges;\n```\n\n10、修改 my.ini文件删除最后一句skip-grant-tables\n\n11、重启mysql即可正常使用\n\n```sql\nnet stop mysql\nnet start mysql\n```\n\n12、连接上测试出现以下结果就安装好了\n\n# 2、定义和操作数据库\n\n> 数据库的操作顺序应该是：数据库->表->表中的数据\n\n**结构化查询语句分类**：\n\n| 名称                | 解释                                         | 命令                                            |\n| ------------------- | -------------------------------------------- | ----------------------------------------------- |\n| DDL(数据库定义语言) | 定义和管理数据对象，如数据库、数据表等       | CREATE,DROP,ALTER,<br />TRUNCATE,COMMENT,RENAME |\n| DML(数据库操作语言) | 用于操作数据库对象种所包含的数据             | INSERT,UPDATE,DELETE                            |\n| DQL(数据库查询语言) | 用于查询数据库数据                           | SELECT                                          |\n| DCL(数据库控制语言) | 用于管理数据库的语言，包括管理权限及数据更改 | GRANT,COMMIT,ROLLBACK,REVOKE                    |\n\n\n\n## 2.1、命令行操作数据库\n\n```sql\n-- 创建数据库\ncreate database [if not exists] database_name;\n-- 删除数据库\ndrop database [if exists] database_name;\n-- 使用数据库\nuse database_name;\n-- 查看数据库\nshow databases;\n```\n\n## 2.2、使用SQLyog操作数据库\n\n### 2.2.1、列类型\n\n#### 2.2.1.1、数据类型\n\n1. 数值类型：tinyint, smallint, mediumint, ==**int**==, bigint, float, **==double==**, ==**decimal**==(字符串形式的浮点数)\n2. 字符串类型：char(固定长字符串，检索快但费空间), **==varchar==**(可变长字符串), tinytext(微型文本串), text(文本串)\n3. 日期和时间型数值类型：date(YY-MM-DD), time(HH: mm: ss), **==datetime==**(YY-MM-DD  HH: mm: ss), **==timestamp==**(时间戳), year(YYYY)\n4. NULL值\n\n#### 2.2.1.2、unsigned\n\n- 无符号的\n- 声明该数据列不允许负数 .\n\n#### 2.2.1.3、ZEROFILL\n\n- 0填充的\n- 不足位数的用0来填充 , 如int(3),5则为005\n\n#### 2.2.1.4、Auto_InCrement\n\n- 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认)\n\n- 通常用于设置**主键** , 且为整数类型\n\n- 可定义起始值和步长\n\n- - 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表\n  - SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)\n\n#### 2.2.1.5、NULL 和 NOT NULL\n\n- 默认为NULL , 即没有插入该列的数值\n- 如果设置为NOT NULL , 则该列必须有值\n\n#### 2.2.1.6、DEFAULT\n\n- 默认的\n- 用于设置默认值\n- 例如,性别字段,默认为\"男\" , 否则为 \"女\" ; 若无指定该列的值 , 则默认值为\"男\"的值\n\n### 2.2.2、MySQL所支持的引擎类型（表类型）\n\n> MyISAM, InnoDB, HEAP, BOB, CSV等\n\n常见的MyISAM和InnoDB对比:\n\n| 名称       | MyISAM | InnoDB      |\n| ---------- | ------ | ----------- |\n| 事务处理   | 不支持 | 支持        |\n| 数据行锁定 | 不支持 | 支持        |\n| 外键约束   | 不支持 | 支持        |\n| 全文索引   | 支持   | 不支持      |\n| 表空间大小 | 较小   | 较大，约2倍 |\n\n经验 ( 适用场合 )  :\n\n- 适用 MyISAM : 节约空间及相应速度\n- 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表\n\n## 2.3、操作数据表（DDL）\n\n```sql\n-- 创建数据表\ncreate table [if not exists] 表名 (\n\t`字段名` 数据类型 列属性(not null default auto_increment comment...) \n)engine=InnoDB default charset=utf8\n-- 删除数据表\ndrop table [if exists] 表名\n-- 查看数据表的结构\ndescribe/desc 表名\n-- 修改数据表\nalter table 表名 add 字段名 列属性(数据类型...)\nalter table 表名 modify 字段名 列属性(要改变的列属性)\nalter table 表名 change 原字段名 新字段名 列属性(要改变的列属性)\n-- modify不能改变列名，只能改变列属性\n-- change可以改变列名也可以改变列属性\n-- 删除数据表中的字段\nalter table 表名 drop 字段名\n```\n\n## 2.4、DML\n\n## 2.4.1、增加\n\n```sql\ninsert into 表名[(字段名1, 字段名2, ...)] values ('值1'...),('值2'...),...\n```\n\n## 2.4.2、修改\n\n```sql\nupdate 表名 set colnum_name = value, [colnum_name = value,...] where [条件]\n```\n\n## 2.4.3、删除\n\n```sql\ndelete from 表名 where [条件] \n```\n\n> TRUNCATE命令\n\n作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;\n\n语法：\n\n```\nTRUNCATE [TABLE] table_name;\n\n-- 清空年级表\nTRUNCATE grade\n```\n\n**注意：区别于DELETE命令**\n\n- 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快\n\n- 不同 :\n\n- - 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器\n  - 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说）\n\n测试：\n\n```sql\n-- 创建一个测试表\nCREATE TABLE `test` (\n`id` INT(4) NOT NULL AUTO_INCREMENT,\n`coll` VARCHAR(20) NOT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\n-- 插入几个测试数据\nINSERT INTO test(coll) VALUES('row1'),('row2'),('row3');\n\n-- 删除表数据(不带where条件的delete)\nDELETE FROM test;\n-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志.\n\n-- 删除表数据(truncate)\nTRUNCATE TABLE test;\n-- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志.\n\n-- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后\n-- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失)\n-- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失)\n```\n\n## 2.5、外键\n\n> 外键概念\n\n如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为**主表**，具有此外键的表被称为主表的**从表**。\n\n在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(**foreign key**)。\n\n**外键作用**\n\n保持数据**一致性**，**完整性**，主要目的是控制存储在外键表中的数据,**约束**。使两张表形成关联，外键只能引用外表中的列的值或使用空值。\n\n> 创建外键\n\n```sql\n-- 以下的操作都是物理外键，数据库级别的外键，不建议使用（避免数据库过多造成困扰）\n-- 数据库就是单纯的表，只用来存数据，只有行(数据)和列(字段)\n-- 我们想使用多张表的数据，想使用外键（用程序去实现）\nCREATE TABLE `grade` (\n\t`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级id',\n\t`gradename` VARCHAR(50) NOT NULL COMMENT '年级名称',\n\tPRIMARY KEY (`gradeid`)\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n-- \n-- 使用外键的方式二：\nCREATE TABLE IF NOT EXISTS `student` (\n\t`id` INT(10) NOT NULL AUTO_INCREMENT COMMENT '学号',\n\t`name` VARCHAR(100) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n\t`pwd` VARCHAR(20) NOT NULL DEFAULT '12345' COMMENT '密码', \n\t`gender` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别',\n\t`birthday` DATETIME DEFAULT NULL COMMENT '出生日期',\n\t`address` VARCHAR(100) DEFAULT NULL COMMENT '地址',\n\t`email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱',\n\t`gradeid` INT(10) DEFAULT NULL COMMENT '年级id',\n\tPRIMARY KEY(`id`)\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nALTER TABLE `student`\nADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`);\n\n-- 使用外键的方式一：\nCREATE TABLE IF NOT EXISTS `student` (\n\t`id` INT(10) NOT NULL AUTO_INCREMENT COMMENT '学号',\n\t`name` VARCHAR(100) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n\t`pwd` VARCHAR(20) NOT NULL DEFAULT '12345' COMMENT '密码', \n\t`gender` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别',\n\t`birthday` DATETIME DEFAULT NULL COMMENT '出生日期',\n\t`address` VARCHAR(100) DEFAULT NULL COMMENT '地址',\n\t`email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱',\n\t`gradeid` INT(10) NOT NULL COMMENT '年级id',\n\tPRIMARY KEY(`id`),\n\tKEY `FK_gradeid` (`gradeid`),\n\tCONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`)\n`school`)ENGINE=INNODB DEFAULT CHARSET=utf8\n```\n\n\n\n# 4、DQL查询数据（最重点）\n\n## 4.1、DQL\n\n> SELECT语法\n\n```sql\nSELECT [ALL | DISTINCT]\n{* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]}\nFROM table_name [as table_alias]\n  [left | right | inner join table_name2]  -- 联合查询\n  [WHERE ...]  -- 指定结果需满足的条件\n  [GROUP BY ...]  -- 指定结果按照哪几个字段来分组\n  [HAVING]  -- 过滤分组的记录必须满足的次要条件\n  [ORDER BY ...]  -- 指定查询记录按一个或多个条件排序\n  [LIMIT {[offset,]row_count | row_countOFFSET offset}];\n   -- 指定查询的记录从哪条至哪条\n```\n\n**注意 : [ ] 括号代表可选的 , { }括号代表必选得**\n\n## 4.2、指定查询字段\n\n```sql\nSELECT * FROM student;\n\nSELECT `StudentNo`, `studentname` FROM student;\n--取别名\nSELECT `StudentNo` AS 学号, `StudentName` AS 姓名 FROM student;\n--使用concat函数\nSELECT CONCAT('姓名：', `StudentName`) AS New_name FROM student; \n```\n\n>去重\n\n```sql\nSELECT DISTINCT `StudentNo` FROM result;\n```\n\n> 使用表达式的列\n\n==数据库中的表达式 : 一般由文本值 , 列值 , NULL , 函数和操作符等组成==\n\n应用场景 :\n\n- SELECT语句返回结果列中使用\n\n- SELECT语句中的ORDER BY , HAVING等子句中使用\n\n- DML语句中的 where 条件语句中使用表达式\n\n  ```\n  -- selcet查询中可以使用表达式\n  SELECT @@auto_increment_increment; -- 查询自增步长\n  SELECT VERSION(); -- 查询版本号\n  SELECT 100*3-1 AS 计算结果; -- 表达式\n  \n  -- 学员考试成绩集体提分一分查看\n  SELECT studentno,StudentResult+1 AS '提分后' FROM result;\n  ```\n\n- 避免SQL返回结果中包含 ' . ' , ' * ' 和括号等干扰开发语言程序.\n\n## 4.3、where条件子句\n\n#### 4.3.1、逻辑操作符\n\n`and`,`or`,`not`可用于查询条件中\n\n#### 4.3.2、模糊查询：比较操作符\n\n```sql\n-- 模糊查询\n-- is null , is not null , like [%/_], in, between and \n\n/*=====is null======*/\n\nSELECT `StudentNo`, `studentname` FROM `student`\nWHERE Address IS NULL OR Address = '';\n\n/*=====is not null======*/\n\nSELECT `StudentNo`, `studentname` FROM `student`\nWHERE address IS NOT NULL;\n\n/*=====like [%/_](通配符)======*/\n\nSELECT `StudentNo`, `studentname` FROM `student`\nWHERE studentname LIKE '刘%';\n\nSELECT `StudentNo`, `studentname` FROM `student`\nWHERE studentname LIKE '_诗诗';\n\nSELECT `StudentNo`, `studentname` FROM `student`\nWHERE studentname LIKE '刘__';\n\nSELECT `StudentNo`, `studentname` FROM `student`\nWHERE studentname LIKE '%德%';\n\n/*=====in======*/\nSELECT `StudentNo`, `studentname`, `GradeID` FROM `student`\nWHERE GradeID IN (1,2,3);\n\n\n/*=====bewteen and======*/\nSELECT `StudentNo`, `studentname`, `GradeID` FROM `student`\nWHERE GradeID BETWEEN 2 AND 3;\n```\n\n## 4.4、连接查询\n\n### 4.4.1、内连接\n\n`[inner]join`:从左表中取出每一条记录，然后到右表中与所有的记录进行匹配，如果查询条件满足就保留，否则不保留。\n\n**字段别名以及表别名的使用**: 在查询数据的时候,不同表有同名字段,这个时候需要加上表名才能区分, 而表名太长, 通常可以使用别名。\n\n**内连接可以没有连接条件**: 没有on之后的内容,这个时候系统会保留所有结果(笛卡尔积)\n\n**内连接还可以使用where代替on关键字，但效率差很多。**\n\n```sql\nSELECT * FROM 左表 INNER JOIN 右表 ON 左表.字段 = 右表.字段\n```\n\n> 注意：其实也可以使用`select * from 表1,表2,...where`这种 `,` (comma) 连接符查询，这种方法和内连接在没有查询条件的时候，在语义上是等效的，都是对指定的表产生笛卡尔积。还有这种查询的优先级是小于所有join连接查询的，所以如果混用对可能出现问题，详情看**[官方文段](https://dev.mysql.com/doc/refman/8.0/en/join.html)**\n\n### 4.4.2、外连接\n\n外连接分为两种: 是以某张表为主: 有主表\n\nleft join: 左外连接(左连接), 以左表为主表\n\nright join: 右外连接(右连接), 以右表为主表\n\n#### 4.4.2.1、左外连接\n\n`left join`:从**左表**中取出每一条记录，然后**到右表中**与所有的记录进行匹配，如果查询条件满足就保留；不满足条件也会保留，但**右表的字段都会置为NULL**。\n\n```sql\nSELECT * FROM 左表(主) LEFT JOIN 右表 ON 左表.字段 = 右表.字段\n```\n\n#### 4.4.2.2、右外连接\n\n`right join`:从**右表**中取出每一条记录，然后**到左表**中与所有的记录进行匹配，如果查询条件满足就保留；不满足条件也会保留，但**左表的字段都会置为NULL**。\n\n```sql\nSELECT * FROM 左表 LEFT JOIN 右表(主) ON 左表.字段 = 右表.字段\n```\n\n### 4.4.3、自然连接（很少用）\n\n`natural join`: 是一种特殊的等值连接，不能使用ON语句，同时也就不用指定连接列，**它默认比较表中所有相同的列**，并在结果中把**相同的属性列去掉**。\n\n```sql\nSELECT * FROM 左表 NATURAL JOIN 右表\n-- 相当于是\nSELECT * FROM 左表 INNER JOIN 右表 ON 左表.字段=右表的字段\n```\n\n### 4.4.4、交叉连接(基本不用)\n\n`cross join`: 将两张表做笛卡尔积运算，就是将左表中每条记录与右表中所有记录连接在一起，最终保留所有的结果\n\n```sql\nSELECT * FROM 左表 CROSS JOIN 右表\n```\n\n### 4.4.5、等值查询与非等值查询\n\n一个用户查询请求涉及到多个表的时候，连接两个表的条件为=时，就是等值连接查询；其他的运算符连接的就是非等值查询。\n\n### 4.4.5、自连接\n\n自连接就是一张表自己跟自己做做笛卡尔积\n\n```sql\nselect * from 表1,表1\n-- 相当于\nselect * 表1 join 表1\n```\n\n## 4.5、分页和排序\n\n```sql\n/*============== 排序 ================\n语法 : ORDER BY\n   ORDER BY 语句用于根据指定的列对结果集进行排序。\n   ORDER BY 语句默认按照ASC升序对记录进行排序。\n   如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n   \n*/\n\n-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)\n-- 按成绩降序排序\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='数据库结构-1'\nORDER BY StudentResult DESC\n\n/*============== 分页 ================\n语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset\n好处 : (用户体验,网络传输,查询压力)\n\n推导:\n   第一页 : limit 0,5\n   第二页 : limit 5,5\n   第三页 : limit 10,5\n   ......\n   第N页 : limit (pageNo-1)*pageSzie,pageSzie\n   [pageNo:页码,pageSize:单页面显示条数]\n   \n*/\n\n-- 每页显示5条数据\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='数据库结构-1'\nORDER BY StudentResult DESC , studentno\nLIMIT 0,5\n\n-- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数)\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='JAVA第一学年'\nORDER BY StudentResult DESC\nLIMIT 0,10\n```\n\n## 4.6、子查询\n\n```sql\n/*============== 子查询 ================\n什么是子查询?\n   在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句\n   嵌套查询可由多个子查询组成,求解的方式是由里及外;\n   子查询返回的结果一般都是集合,故而建议使用IN关键字;\n*/\n-- 查询课程为'JAVA第一学年'且分数不小于80分的同学的学号和姓名\n-- \nSELECT student.StudentNo, StudentName \nFROM student\nINNER JOIN result\nON student.`StudentNo` = result.`StudentNo`\nINNER JOIN `subject`\nON result.`SubjectNo` = subject.`SubjectNo`\nWHERE result.`StudentResult` >= 80 AND subject.`SubjectName` = 'JAVA第一学年'\n\n-- 子查询1\nSELECT student.`StudentNo`, StudentName\nFROM student\nINNER JOIN result\nON student.`StudentNo` = result.`StudentNo`\nWHERE result.`StudentResult` >= 80 AND result.`SubjectNo`= (\n\tSELECT subject.`SubjectNo`\n\tFROM `subject`\n\tWHERE subject.`SubjectName` = 'JAVA第一学年'\n)\n\n-- 子查询2\nSELECT StudentNo, StudentName FROM student \nWHERE StudentNo IN (\n\tSELECT StudentNo FROM result\n\tWHERE StudentResult >= 80 AND SubjectNo  = (\n\t\tSELECT SubjectNo FROM `subject`\n\t\tWHERE subject.`SubjectName` = 'JAVA第一学年'\n\t)\n)\n```\n\n\n\n## 4.7、分组和过滤\n\n```sql\n -- 查询不同课程的平均分,最高分,最低分\n -- 前提:根据不同的课程进行分组\n \n -- 使用GROUP BY 进行分组， HANING对分组结果再进行过滤\n \n SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分\n FROM result AS r\n INNER JOIN `subject` AS s\n ON r.subjectno = s.subjectno\n GROUP BY r.subjectno\n HAVING 平均分>80;\n```\n\n\n\n# 5、函数\n\n## 5.1、常用函数（略）\n\n## 5.2、聚合函数（常用）\n\n```sql\nCOUNT()\n\t/--COUNT(字段)\n\t/--COUNT(*)\n\t/--COUNT(1)\nSUM()\nMAX()\nMIN()\nAVG()\n```\n\n## MD5 加密\n\n**一、MD5简介**\n\nMD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。\n\n**二、实现数据加密**\n\n新建一个表 testmd5\n\n```\n CREATE TABLE `testmd5` (\n  `id` INT(4) NOT NULL,\n  `name` VARCHAR(20) NOT NULL,\n  `pwd` VARCHAR(50) NOT NULL,\n  PRIMARY KEY (`id`)\n ) ENGINE=INNODB DEFAULT CHARSET=utf8\n```\n\n插入一些数据\n\n```\n INSERT INTO testmd5 VALUES(1,'kuangshen','123456'),(2,'qinjiang','456789')\n```\n\n如果我们要对pwd这一列数据进行加密，语法是：\n\n```\n update testmd5 set pwd = md5(pwd);\n```\n\n如果单独对某个用户(如kuangshen)的密码加密：\n\n```\n INSERT INTO testmd5 VALUES(3,'kuangshen2','123456')\n update testmd5 set pwd = md5(pwd) where name = 'kuangshen2';\n```\n\n插入新的数据自动加密\n\n```\n INSERT INTO testmd5 VALUES(4,'kuangshen3',md5('123456'));\n```\n\n查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对）\n\n```\n SELECT * FROM testmd5 WHERE `name`='kuangshen' ANDpwd=MD5('123456');\n```\n\n# 6、事务和索引\n\n## 6.1、事务\n\n> 什么是事务\n\n- 事务就是将一组SQL语句放在同一批次内去执行\n- 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行\n- MySQL事务处理只支持InnoDB和BDB数据表类型\n\n> 事务的ACID原则  百度 ACID\n\n**原子性(Atomic)**\n\n- **整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节**。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n**一致性(Consist)**\n\n- 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。\n\n**隔离性(Isolated)**\n\n- 事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰\n\n**持久性(Durable)**\n\n- 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n> **基本语法**\n\n```sql\n-- 使用set语句来改变自动提交模式\nSET autocommit = 0;   /*关闭*/\nSET autocommit = 1;   /*开启*/\n-------------------------------------------------------\n-- 注意:\n--- 1.MySQL中默认是自动提交\n--- 2.使用事务时应先关闭自动提交\n\n-- 开始一个事务,标记事务的起始点\nSTART TRANSACTION  \n\n-- 提交一个事务给数据库\nCOMMIT\n\n-- 将事务回滚,数据回到本次事务的初始状态\nROLLBACK\n\n-- 还原MySQL数据库的自动提交\nSET autocommit =1;\n\n-- 保存点\nSAVEPOINT 保存点名称 -- 设置一个事务保存点\nROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点\nRELEASE SAVEPOINT 保存点名称 -- 删除保存点\n```\n\n\n\n> 测试\n\n```sql\n/*\n课堂测试题目\n\nA在线买一款价格为500元商品,网上银行转账.\nA的银行卡余额为2000,然后给商家B支付500.\n商家B一开始的银行卡余额为10000\n\n创建数据库shop和创建表account并插入2条数据\n*/\n\nCREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci;\nUSE `shop`;\n\nCREATE TABLE `account` (\n`id` INT(11) NOT NULL AUTO_INCREMENT,\n`name` VARCHAR(32) NOT NULL,\n`cash` DECIMAL(9,2) NOT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT INTO account (`name`,`cash`)\nVALUES('A',2000.00),('B',10000.00)\n\n-- 转账实现\nSET autocommit = 0; -- 关闭自动提交\nSTART TRANSACTION;  -- 开始一个事务,标记事务的起始点\nUPDATE account SET cash=cash-500 WHERE `name`='A';\nUPDATE account SET cash=cash+500 WHERE `name`='B';\nCOMMIT; -- 提交事务\n# rollback;\nSET autocommit = 1; -- 恢复自动提交\n```\n\n## 6.2、索引\n\n> 索引的作用\n\n- 提高查询速度\n- 确保数据的唯一性\n- 可以加速表和表之间的连接 , 实现表与表之间的参照完整性\n- 使用分组和排序子句进行数据检索时 , 可以显著减少分组和排序的时间\n- 全文检索字段进行搜索优化.\n\n> 分类\n\n- 主键索引 (Primary Key)\n- 唯一索引 (Unique)\n- 常规索引 (key/Index)\n- 全文索引 (FullText)\n\n> 主键索引\n\n主键 : 某一个属性组能唯一标识一条记录(不能有NULL值)\n\n> 注:为什么说是一个属性组呢?因为有时候只有一个属性并不能唯一标识一条记录，比如说，学生表中，学号能唯一确定一个学生，课程表中，课程编号能唯一确定一门课程，但是在成绩表中，只有一个学号并不能唯一标识一条记录，只有学号和课程编号组合起来才能唯一标识一条记录\n>\n> ```sql\n> CREATE TABLE `result` (\n> \t`StudentId` INT(6) NOT NULL,\n> \t`CourseId` INT(10) NOT NULL,\n> \t`score` INT(3) NULL,\n> \tCONSTRAINT pk_name PRIMARY KEY(`StudentId`,`CourseId`)\n> )ENGINE=INNODB DEFAULT CHARSET=utf8\n> ```\n\n特点 :\n\n- 最常见的索引类型\n- 确保数据记录的唯一性\n- 确定特定数据记录在数据库中的位置\n\n> 唯一索引\n\n作用 : 避免同一个表中某数据列中的值重复(可以有NULL值，而且可重复【null表示未知，这不违反唯一约束】)\n\n与主键索引的区别\n\n- 主键索引只能有一个\n- 唯一索引可能有多个\n\n```sql\nCREATE TABLE `Grade`(\n  `GradeID` INT(11) AUTO_INCREMENT PRIMARYKEY,\n  `GradeName` VARCHAR(32) NOT NULL UNIQUE\n   -- 或 UNIQUE KEY `GradeID` (`GradeID`)\n)\n```\n\n> 常规索引\n\n作用 : 快速定位特定数据\n\n注意 :\n\n- index 和 key 关键字都可以设置常规索引\n- 应加在查询找条件的字段\n- 不宜添加太多常规索引,影响数据的插入,删除和修改操作\n\n```sql\nCREATE TABLE `result`(\n   -- 省略一些代码\n  INDEX/KEY `ind` (`studentNo`,`subjectNo`) -- 创建表时添加\n)\n-- 创建后添加\nALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`);\n```\n\n> 全文索引\n\n百度搜索：全文索引\n\n作用 : 快速定位特定数据\n\n注意 :\n\n- 只能用于MyISAM类型的数据表\n- 只能用于CHAR , VARCHAR , TEXT数据列类型\n- 适合大型数据集\n\n```sql\n/*\n#方法一：创建表时\n  　　CREATE TABLE 表名 (\n               字段名1 数据类型 [完整性约束条件…],\n               字段名2 数据类型 [完整性约束条件…],\n               [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY\n               [索引名] (字段名[(长度)] [ASC |DESC])\n               );\n\n\n#方法二：CREATE在已存在的表上创建索引\n       CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名\n                    ON 表名 (字段名[(长度)] [ASC |DESC]) ;\n\n\n#方法三：ALTER TABLE在已存在的表上创建索引\n       ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX\n                            索引名 (字段名[(长度)] [ASC |DESC]) ;\n                           \n                           \n#删除索引：DROP INDEX 索引名 ON 表名字;\n#删除主键索引: ALTER TABLE 表名 DROP PRIMARY KEY;\n\n\n#显示索引信息: SHOW INDEX FROM student;\n*/\n\n/*增加全文索引*/\nALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname` (`StudentName`);\n\n/*EXPLAIN : 分析SQL语句执行性能*/\nEXPLAIN SELECT * FROM student WHERE studentno='1000';\n\n/*使用全文索引*/\n-- 全文搜索通过 MATCH() 函数完成。\n-- 搜索字符串作为 against() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。\nEXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST('love');\n\n/*\n开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况\n\nMySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；\nMySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;\n只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。\n测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。\n*/\n```\n\n> 拓展：测试索引\n\n**建表app_user：**\n\n```sql\nCREATE TABLE `app_user` (\n`id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n`name` varchar(50) DEFAULT '' COMMENT '用户昵称',\n`email` varchar(50) NOT NULL COMMENT '用户邮箱',\n`phone` varchar(20) DEFAULT '' COMMENT '手机号',\n`gender` tinyint(4) unsigned DEFAULT '0' COMMENT '性别（0:男；1：女）',\n`password` varchar(100) NOT NULL COMMENT '密码',\n`age` tinyint(4) DEFAULT '0' COMMENT '年龄',\n`create_time` datetime DEFAULT CURRENT_TIMESTAMP,\n`update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ONUPDATE CURRENT_TIMESTAMP,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='app用户表'\n```\n\n**批量插入数据：100w**\n\n```sql\nDROP FUNCTION IF EXISTS mock_data;\nDELIMITER $$\nCREATE FUNCTION mock_data()\nRETURNS INT\nBEGIN\nDECLARE num INT DEFAULT 1000000;\nDECLARE i INT DEFAULT 0;\nWHILE i < num DO\n  INSERT INTO app_user(`name`, `email`, `phone`, `gender`, `password`, `age`)\n   VALUES(CONCAT('用户', i), '24736743@qq.com', CONCAT('18', FLOOR(RAND()*(999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(), FLOOR(RAND()*100));\n  SET i = i + 1;\nEND WHILE;\nRETURN i;\nEND;\nSELECT mock_data();\n```\n\n**索引效率测试**\n\n无索引\n\n```sql\nSELECT * FROM app_user WHERE name = '用户9999'; -- 查看耗时\nSELECT * FROM app_user WHERE name = '用户9999';\nSELECT * FROM app_user WHERE name = '用户9999';\n\nmysql> EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G\n*************************** 1. row ***************************\n          id: 1\nselect_type: SIMPLE\n       table: app_user\n  partitions: NULL\n        type: ALL\npossible_keys: NULL\n        key: NULL\n    key_len: NULL\n        ref: NULL\n        rows: 992759\n    filtered: 10.00\n      Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n```\n\n创建索引\n\n```sql\nCREATE INDEX idx_app_user_name ON app_user(name);\n```\n\n测试普通索引\n\n```sql\nmysql> EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G\n*************************** 1. row ***************************\n          id: 1\nselect_type: SIMPLE\n       table: app_user\n  partitions: NULL\n        type: ref\npossible_keys: idx_app_user_name\n        key: idx_app_user_name\n    key_len: 203\n        ref: const\n        rows: 1\n    filtered: 100.00\n      Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n\nmysql> SELECT * FROM app_user WHERE name = '用户9999';\n1 row in set (0.00 sec)\n\nmysql> SELECT * FROM app_user WHERE name = '用户9999';\n1 row in set (0.00 sec)\n\nmysql> SELECT * FROM app_user WHERE name = '用户9999';\n1 row in set (0.00 sec)\n```\n\n> 索引准则\n\n- 索引不是越多越好\n- 不要对经常变动的数据加索引\n- 小数据量的表建议不要加索引\n- 索引一般应加在查找条件的字段\n\n> 索引的数据结构\n\n```sql\n-- 我们可以在创建上述索引的时候，为其指定索引类型，分两类\nhash类型的索引：查询单条快，范围查询慢\nbtree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）\n\n-- 不同的存储引擎支持的索引类型也不一样\nInnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；\nMyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；\nMemory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；\nNDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；\nArchive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text等索引；\n```\n\n# 7、权限及如何设计数据库\n\n### 用户管理\n\n> 使用SQLyog 创建用户，并授予权限演示\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Jf7deolwQa44rXvicIhXZ0NGL4sZKg8nicBGrYlEBJh1V3ymJ4WzBx9zXsIZyPYFADJBzn0ibCmgiauA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n> 基本命令\n\n```sql\n/* 用户和权限管理 */ ------------------\n用户信息表：mysql.user\n\n-- 刷新权限\nFLUSH PRIVILEGES\n\n-- 增加用户 CREATE USER kuangshen IDENTIFIED BY '123456'\nCREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)\n  - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。\n  - 只能创建用户，不能赋予权限。\n  - 用户名，注意引号：如 'user_name'@'192.168.1.1'\n  - 密码也需引号，纯数字密码也要加引号\n  - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD\n\n-- 重命名用户 RENAME USER kuangshen TO kuangshen2\nRENAME USER old_user TO new_user\n\n-- 设置密码\nSET PASSWORD = PASSWORD('密码')    -- 为当前用户设置密码\nSET PASSWORD FOR 用户名 = PASSWORD('密码')    -- 为指定用户设置密码\n\n-- 删除用户 DROP USER kuangshen2\nDROP USER 用户名\n\n-- 分配权限/添加用户\nGRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD]'password']\n  - all privileges 表示所有权限【除grant权限外的所有权限】\n  - *.* 表示所有库的所有表\n  - 库名.表名 表示某库下面的某表\n\n-- 查看权限   SHOW GRANTS FOR root@localhost;\nSHOW GRANTS FOR 用户名\n   -- 查看当前用户权限\n  SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\n\n-- 撤消权限\nREVOKE 权限列表 ON 表名 FROM 用户名\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名    -- 撤销所有权限\n```\n\n> 权限解释\n\n```sql\n-- 权限列表\nALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限\nALTER    -- 允许使用ALTER TABLE\nALTER ROUTINE    -- 更改或取消已存储的子程序\nCREATE    -- 允许使用CREATE TABLE\nCREATE ROUTINE    -- 创建已存储的子程序\nCREATE TEMPORARY TABLES        -- 允许使用CREATE TEMPORARY TABLE\nCREATE USER        -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。\nCREATE VIEW        -- 允许使用CREATE VIEW\nDELETE    -- 允许使用DELETE\nDROP    -- 允许使用DROP TABLE\nEXECUTE        -- 允许用户运行已存储的子程序\nFILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE\nINDEX     -- 允许使用CREATE INDEX和DROP INDEX\nINSERT    -- 允许使用INSERT\nLOCK TABLES        -- 允许对您拥有SELECT权限的表使用LOCK TABLES\nPROCESS     -- 允许使用SHOW FULL PROCESSLIST\nREFERENCES    -- 未被实施\nRELOAD    -- 允许使用FLUSH\nREPLICATION CLIENT    -- 允许用户询问从属服务器或主服务器的地址\nREPLICATION SLAVE    -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）\nSELECT    -- 允许使用SELECT\nSHOW DATABASES    -- 显示所有数据库\nSHOW VIEW    -- 允许使用SHOW CREATE VIEW\nSHUTDOWN    -- 允许使用mysqladmin shutdown\nSUPER    -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。\nUPDATE    -- 允许使用UPDATE\nUSAGE    -- “无权限”的同义词\nGRANT OPTION    -- 允许授予权限\n\n\n/* 表维护 */\n\n-- 分析和存储表的关键字分布\nANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...\n-- 检查一个或多个表是否有错误\nCHECK TABLE tbl_name [, tbl_name] ... [option] ...\noption = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}\n-- 整理数据文件的碎片\nOPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n```\n\n\n\n### MySQL备份\n\n数据库备份必要性\n\n- 保证重要数据不丢失\n- 数据转移\n\nMySQL数据库备份方法\n\n- mysqldump备份工具\n- 数据库管理工具,如SQLyog\n- 直接拷贝数据库文件和相关配置文件\n\n**mysqldump客户端**\n\n作用 :\n\n- 转储数据库\n- 搜集数据库进行备份\n- 将数据转移到另一个SQL服务器,不一定是MySQL服务器\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Jf7deolwQa44rXvicIhXZ0NzgWJWeyYYcf1Dy3ibfN66SiaZQmqTF3Hv8HBjr1zIowXh201pEjUzyJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n```sql\n-- 导出\n1. 导出一张表 -- mysqldump -uroot -p123456 school student >D:/a.sql\n　　mysqldump -u用户名 -p密码 库名 表名 > 文件名(D:/a.sql)\n2. 导出多张表 -- mysqldump -uroot -p123456 school student result >D:/a.sql\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 > 文件名(D:/a.sql)\n3. 导出所有表 -- mysqldump -uroot -p123456 school >D:/a.sql\n　　mysqldump -u用户名 -p密码 库名 > 文件名(D:/a.sql)\n4. 导出一个库 -- mysqldump -uroot -p123456 -B school >D:/a.sql\n　　mysqldump -u用户名 -p密码 -B 库名 > 文件名(D:/a.sql)\n\n可以-w携带备份条件\n\n-- 导入\n1. 在登录mysql的情况下：-- source D:/a.sql\n　　use database_name (选择导入的数据库)\n　　source 备份文件\n2. 在不登录的情况下（不推荐）\n　　mysql -u用户名 -p密码 库名 < 备份文件\n```\n\n\n\n## 规范化数据库设计\n\n### 为什么需要数据库设计\n\n**当数据库比较复杂时我们需要设计数据库**\n\n**糟糕的数据库设计 :** \n\n- 数据冗余,存储空间浪费\n- 数据更新和插入的异常\n- 程序性能差\n\n**良好的数据库设计 :** \n\n- 节省数据的存储空间\n- 能够保证数据的完整性\n- 方便进行数据库应用系统的开发\n\n **软件项目开发周期中数据库设计 :**\n\n- 需求分析阶段: 分析客户的业务和数据处理需求\n- 概要设计阶段:设计数据库的E-R模型图 , 确认需求信息的正确和完整.\n\n**设计数据库步骤**\n\n- 收集信息\n\n- - 与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务.\n\n- 标识实体[Entity]\n\n- \n\n- - 标识数据库要管理的关键对象或实体,实体一般是名词\n\n- 标识每个实体需要存储的详细信息[Attribute]\n\n- 标识实体之间的关系[Relationship]\n\n\n\n### 三大范式\n\n**问题 : 为什么需要数据规范化?**\n\n不合规范的表设计会导致的问题：\n\n- 信息重复\n\n- 更新异常\n\n- 插入异常\n\n- - 无法正确表示信息\n\n- 删除异常\n\n- - 丢失有效信息\n\n> 三大范式\n\n**第一范式 (1st NF)**\n\n第一范式的目标是确保每列的原子性,如果每列都是不可再分的最小数据单元,则满足第一范式\n\n**第二范式(2nd NF)**\n\n第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。\n\n第二范式要求每个表只描述一件事情\n\n**第三范式(3rd NF)**\n\n如果一个关系满足第二范式,并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式.\n\n第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。\n\n\n\n**规范化和性能的关系**\n\n为满足某种商业目标 , 数据库性能比规范化数据库更重要\n\n在数据规范化的同时 , 要综合考虑数据库的性能\n\n通过在给定的表中添加额外的字段,以大量减少需要从中搜索信息所需的时间\n\n通过在给定的表中插入计算列,以方便查询","tags":["MySQL"],"categories":["MySQL"]},{"title":"HashMap","url":"/2021/08/12/HashMap/","content":"\n# HashMap\n\nHashMap实现了Map这个接口，而Map就是表示的一对键值对(key, value)的映射关系，一个key映射一个value，key不能重复，给同一个Key赋值会覆盖原来的值。Hash表是将key通过散列函数hash(x)散列到Hash表上，形成的一个映射关系。这不就是Map的一种实现吗？但是仅仅依靠散列函数是不行的，因为会存在散列冲突，而HashMap中解决冲突的方法是**链地址法**。\n\n<!--more-->\n\n### Map接口  \n\n`JDK1.7`版本\n\n```java\npublic interface Map<K,V> {\n\tV put(K key, V value);//保存键值对，如果原来有key，覆盖，返回原来的值\n    V get(Object key);// 根据键获取值，没找到，返回null\n    V remove(Object key);// 根据键删除键值对，返回key原来的值，如果不存在，返回null\n    int size();//查看键值对的个数\n    Set<K> keySet();//获取Map中键的集合\n    Set<Map.Entry<K,V>> entrySet();//获取Map中所有的键值对\n    Collection<V> values();\n    interface Entry<K, V> {\n\t\tK getKey();\n        V getValue();\n        V setValue();\n        boolean equals(Object o);\n        int hashCode();\n    }\n    ....\n}\n```\n\n> keySet(), values(), entrySet()有一个共同的特点，它们返回的都是视图，不是赋值的值，基于返回值的修改会直接修改Map自身\n\n以上就是Map的部分API，我们现在就是要使用哈希表这个数据结构来实现Map这个抽象数据结构。\n\n### HashMap的结构组成\n\n为了避免散列冲突，HashMap使用的是**链地址法**解决冲突的问题。所以采用了**数组+链表**的结构来构成hash表。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/HashMap.png\" style=\"zoom: 80%;\" />\n\n上图就展示了HashMap真正的结构，数组是由一个个`Entry<V,K>`组成的，Entry有一个next的指针去链接冲突元素，这里采用了`头插法`添加元素。**注意：这里的`null`是因为我们只给对象数组table进行了初始化，此时每个元素都是默认值null，还需要对每个entry对象进行实例化。**\n\n让我们来结合代码对HashMap的结构更深入的理解\n\n### HashMap的代码\n\n#### 1.内部组成\n\n```java\npublic class HashMap<K,V>\n    extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n{\n\n    /**\n     * The default initial capacity - MUST be a power of two.\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    /**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /**\n     * The load factor used when none specified in constructor.\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * An empty table instance to share when the table is not inflated.\n     */\n    static final Entry<?,?>[] EMPTY_TABLE = {};\n\n    /**\n     * The table, resized as necessary. Length MUST Always be a power of two.\n     */\n    transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n\n    /**\n     * The number of key-value mappings contained in this map.\n     */\n    transient int size;\n\n    /**\n     * The next size value at which to resize (capacity * load factor).\n     * @serial\n     */\n    // If table == EMPTY_TABLE then this is the initial capacity at which the\n    // table will be created when inflated.\n    int threshold;\n\n    /**\n     * The load factor for the hash table.\n     *\n     * @serial\n     */\n    final float loadFactor;\n\n    /**\n     * The number of times this HashMap has been structurally modified\n     * Structural modifications are those that change the number of mappings in\n     * the HashMap or otherwise modify its internal structure (e.g.,\n     * rehash).  This field is used to make iterators on Collection-views of\n     * the HashMap fail-fast.  (See ConcurrentModificationException).\n     */\n    transient int modCount;\n\n     static class Entry<K,V> implements Map.Entry<K,V> {\n            final K key;\n            V value;\n            Entry<K,V> next;\n            int hash;\n\n            /**\n             * Creates new entry.\n             */\n            Entry(int h, K k, V v, Entry<K,V> n) {\n                value = v;\n                next = n;\n                key = k;\n                hash = h;\n            }\n\n            public final K getKey() {\n                return key;\n            }\n\n            public final V getValue() {\n                return value;\n            }\n\n            public final V setValue(V newValue) {\n                V oldValue = value;\n                value = newValue;\n                return oldValue;\n            }\n     }\n}\n```\n\n> 上面就是JDK1.7 SE中HashMap的内部结构\n\n从源码中我们就可以看出`table`是一个`Entry`类型的数组，成为哈希表或哈希桶，其中每个元素指向一个单向链表，链表上的每个元素表示一个键值对。`table`的初始值是`EMPTY_TABLE`，一个空表。只有当添加元素的时候，才会给`table`分配空间。添加第一个元素的时候，默认分配的大小为16，此时`table`数组的大小为16，每个元素都是默认值null。只有在调用`createEntry()`方法时，才会进行实例化，后面会讲到。`table`的大小会随着键值对增加进行扩展，至于什么时候进行扩展，要取决于`threshold`，当键值对个数`size`大于等于`threshold`时就会进行扩展，而`threshold = table.length * loadFator`，装载因子`loadFactor`默认为0.75。\n\n#### 2.默认构造方法\n\n```java\npublic HashMap() {\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n}\n\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n\n    this.loadFactor = loadFactor;\n    threshold = initialCapacity;\n    init();\n}\n```\n\n#### 3.保存键值对: put()\n\n```java\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);\n    return null;\n}\n```\n\n如果是第一次保存，会先调用`inflateTable()`方法给`table`分配实际的空间，想想为什么第一次传入的是`threshold`？\n\n```java\n private void inflateTable(int toSize) {\n    // Find a power of 2 >= toSize\n    int capacity = roundUpToPowerOf2(toSize);\n\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n```\n\n接下来会检查`key`是否为`null`，如果是则会调用`putForNullKey`单独处理，会将这个key为null的，单独存储在table[0]或者table[0]所指的冲突链上。 \n\n```java\nprivate V putForNullKey(V value) {\n    //查找存不存在key为null的元素\n    for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n        if (e.key == null) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    //没有key为null的元素，则添加一个\n    addEntry(0, null, value, 0);\n    return null;\n}\n```\n\n当`key`不为`null`时，会调用`hash()`方法计算出`key`的hashcode\n\n```java\ninal int hash(Object k) {\n    /*\n    int h = hashSeed;\n    if (0 != h && k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\t*/\n    h ^= k.hashCode();\n\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看出，基于k自身的hashCode方法的返回值又进行了一些位运算，目的是为了随机和均匀性。有了hashcode之后，我们就调用`indexFor()`方法，计算hashcode应该映射到`table`的哪个位置（下标）\n\n```java\nstatic int indexFor(int h, int length) {\n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n\n对于上面的`h & (length-1)`运算进行解释，首先`table`的长度都会被限制在`non-zero power of 2`,在初始化数组的时候，有一个`roundUpToPowerOf2(toSize)`方法保证了这一点。因为当length为${2^n}$时，`h & (length-1)`就相当于是求模运算`h % length`，`&`与运算的速度要快于普通的求余运算，所以才会这样设计。\n\n> 为什么length=${2^n}$时，h & (length-1)会相当于h % length呢？\n>\n> h与${2^n}-1$进行与运算，相当于只取h二进制的后n位，因为${2^n}-1$的后n位都是1，所以与运算时，只会保留h的后n位。\n>\n> h % ${2^n}$:二进制除法相当于右位移`>>`，例如`111010>>3`,即除以$2^{3}$，右移3位变为`111`，`010`则作为余数被移除，故在做取余操作时值为`010`，即为h的n个最低位数字。\n>\n> 经过上面的解释我们就可以直到当length=${2^n}$，h & (length-1) = h % length\n\n上面我们分析得到了key被映射到table的位置，下面就是在**table[i]和table[i]的冲突链**中逐个查找是否已经有这个键了。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n\n遍历代码：\n\n```java\nfor (Entry<K,V> e = table[i]; e != null; e = e.next)\n```\n\n比较的时候，先使用hashcode进行比较，hashcode相同时，再使用equals方法进行比较\n\n```java\nif (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n```\n\n 为什么要先比较hashcode呢？因为hashcode是整数，比较的效率肯定是要比equals方法高的，如果hashcode都不相同，那么就没有必要再比较equals了。这也是为什么要在Entry中加入hashcode这个字段的原因。\n\n如果存在该key，那么我们就将这个Entry中的value替换掉，并且返回原来的那个value。\n\n如果不存在该key，那么就会调用`addEntry()`方法在计算出的散列位置上添加一个Entry\n\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\n```\n\n先要检查散列表的长度是不是大于等于`threshold`，且table[bucketIndex]是不是为null。这是什么意思呢？首先我们想一想为什么要扩容，我们主要不是位置不够了，而是怕出现哈希冲突，因为`table.length`大于`thershold`，哈希冲突出现的可能性就会很大。好，那如果我们要插入的当前位置不存在冲突，刚好就有空位置，那就没有必要去扩容了啊，直接插入不就可以了。\n\n因此只有在`size>=threshold`并且正好存在哈希冲突时，才会进行扩容。这样的设计是具有合理性的，因为每次进行扩容时都是分耗费时间的，所以能少用`resize()`方法就少用。\n\n```java\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n上面是`createEntry()`方法，采用了`头插法`进行插入。\n\n```java\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n```\n\n扩容的策略就是原来容量的`两倍`，会调用`transfer()`方法将原来哈希表中的键值对移动到newTable中的新的位置，因为哈希表的大小发生了变化，所以哈希地址(索引)要重新进行计算，所以说这是一个比较费事的操作。\n\n```java\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry<K,V> e : table) {\n        while(null != e) {\n            Entry<K,V> next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n> 注：resize一般为false.\n\n---\n\n以上保存键值对的所有代码，简单总结一下基本步骤：\n\n1. 计算键的哈希值\n2. 根据哈希值得到保存位置（取模）\n3. 插入对应位置的链表头部或更新已有值\n4. 根据需要扩展table大小\n\n下面是一个流程图，方便顺理整个流程。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/hashmap_put.jpg\" style=\"zoom:67%;\" />\n\n下面是一个时间出入操作的例子：\n\n```java\nMap<String, Integer> countMap = new HashMap<>();\ncountMap.put(\"hello\", 1);\ncountMap.put(\"world\", 3);\ncountMap.put(\"position\", 4);\n```\n\n下图是通过`new HashMap()`创建一个对象后，内存中的结构：\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/image-20210809154531667.png\" alt=\"image-20210809154531667\" style=\"zoom:33%;\" />\n\n下图是经过三次put操作后，得到的内存结构：\n\n![image-20210809154248278](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/image-20210809154248278.png)","tags":["hashmap"],"categories":["Java"]},{"title":"Git中关于LF和CRLF转换问题","url":"/2021/08/12/Git中关于LF和CRLF转换问题/","content":"\n\n\n今天本来要准备系统的学习一下git的使用，到[awesome-git](https://github.com/dictcp/awesome-git)上面找了一个教程，结果直接上来就是让我配置`core.autocrlf`和`core.safecrlf`这两个配置，然后就去搜索了这两个配置是干什么的。这才让我意识到换行在`window`、`linux`和`UNIX/Linux`上是不一样的。\n\n<!--more-->\n\n## 1.CR、LF和CRLF之间的不同\n\n* `CR: 回车(Carriage Return)`，用符号`'\\r'`表示，`ASCII`代码是**13**，十六进制代\n*  码为`0x0D`\n* `LF: 换行(Line Feed)`，使用`'\\n'`符号表示, `ASCII`代码是**10**, 十六制为`0x0A`\n* `CRLF: 回车换行`，使用`'\\r\\n'`符号表示\n## 2.三个平台上面使用的不同\n\n1. `windows`上面一直使用的是`CRLF`\n1. `UNIX/Linux`上面一直使用的是`LF`\n1. `OS X`早期的 Mac OS 使用的是`0x0D(CR)`，后来的 OS X 在更换内核后与 UNIX 保持一致了，也是用`LF`\n\n---\n\n现在三大平台上面只有`windows`是使用`CRLF`，其他都是`LF`。\n## 3.Git上提供的`LF`和`CRLF`转换的配置\n`core.autocrlf`和`core.safecrlf`是git为我们提供的转换配置和检查配置\n```bash\nAutoCRLF\n\n#提交时转换为LF，检出时转换为CRLF\ngit config --global core.autocrlf true\n\n#提交时转换为LF，检出时不转换\ngit config --global core.autocrlf input\n\n#提交检出均不转换\ngit config --global core.autocrlf false\n----------------------------------------\nSafeCRLF\n\n#拒绝提交包含混合换行符的文件\ngit config --global core.safecrlf true\n\n#允许提交包含混合换行符的文件\ngit config --global core.safecrlf false\n\n#提交包含混合换行符的文件时给出警告\ngit config --global core.safecrlf warn\n```\n如果设置为`core.autocrlf = true`的话，在window平台提交时，会将`CRLF`转为`LF`放到仓库，检出时，又会将`LF`转换为`CRLF`，那这样就会保持仓库中的一直都是`LF`。\n但是这并不是最好的做法！！\n最好的做法是从一开始就保证文件中的是`LF`，这样就不用再担心换行出现问题，而且可以设置`core.safecrlf = ture`，来帮助我们检查是否有混合换行符。\n\n\n## 4.在编辑器中设置为`LF`\n### IntelliJ IDEA\n\n1. 在`settings`中找到`Editor`，然后点击`Code Style`设置`line separator`为`Unix and OS X(\\n)`即可\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628672442482-6826ef57-eff4-452c-9eb2-002ad784a249.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n### Typora\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628672547694-8a8a0dd3-fb8d-4510-b95a-a8dfe848ce00.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n### VSCode\n在`Settings`中搜索`eol`可以看到默认是`auto`，也就是跟随系统自身。我们可以更改为`\\n`​\n当然如果是项目的话，推荐使用`.editorconfig`来配置。\n通过下面这篇文章可以学习使用怎么配`.editorconfig`\n[vscode使用editorconfig插件以及.editorconfig配置文件说明详解](https://www.jb51.net/article/185751.htm)\n​\n\n> 参考资料：\n> [git 换行符LF与CRLF转换问题 IDE的默认换行符设置为LF](https://blog.csdn.net/weixin_36836847/article/details/96115090)\n> [Git官方配置](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration)​\n\n","tags":["CRLF"],"categories":["Git"]},{"title":"GitHub+jsDelivr搭建图床","url":"/2021/08/12/GitHub+jsDelivr搭建图床/","content":"\n昨天在看的`algorithm-base`时候看到作者用的图片链接中是`https://www.jsdelivr.com/gh/...`就好奇搜索了一下，发现原来可以使用`GitHub+jsDelivr+PicGo`来搭建一个图床。本想着自己也用不到图床，反正文章都是上传到语雀上面。但是今天在leetcode做题时，想要写一个题解（还是在ppt上画了老半天的图），结果leetcode上面不能上传图片，看来就只能使用图床了。下面就简单介绍一下怎么搭建的步骤吧，网上其实已经有很多的教程了。\n\n<!--more-->\n\n## 1.在github上面创建一个新的repository\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628587571744-13b95c14-07a8-4efa-9484-d608c66ba88f.png)\n## 2.生成个人访问令牌Token\n\n1. 进入`Settings`\n1. 点击`developer settings`\n1. 点击`Personal access tokens`\n\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594005901-7269e41c-4a18-4f83-b719-756e4798ed68.png)\n然后填写相应的信息\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594227248-65152815-c84f-48c2-a3d5-a717d8fba4f8.png)\n最后生成Token，记得保存，只会保留一次\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594342407-54ea612e-58e1-4951-b93b-97e3a268dc2e.png)\n\n## 3.下载和配置PicGo\n[下载地址](https://github.com/Molunerfinn/PicGo/releases)\n\n1. 先安装插件`github-puls`，该插件是用来将图片上传到gitee或github上，比自带的github图床方便(自带的没有办法删除远程记录)\n1. 到图床设置中找到githubpuls先进行配置\n\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628594748299-f0c5052e-6db2-4f44-ac3e-8bc129e2c09f.png)\n> repo: 就是刚才创建的github仓库\n> branch: 分支，默认时master，也可以是其他的分支\n> token: 刚才从github上生成的\n> path: 仓库下的路径（需要现在仓库中创建相应的文件夹）**要清楚文件夹和文件的路径区别**​\n> customUrl: 自定义路径，这里我们使用jsDelivr免费的CND为我们进行加速\n> orgin: 所要上传的地址，这里我们是github\n\njsDelivr的格式：`https://cdn.jsdelivr.net/gh/user/repo@version/file`\n官网上都有介绍: [jsDelivr](https://www.jsdelivr.com/)\n![image.png](images/GitHub+jsDelivr搭建图床.assets/1628595754598-812ae538-a6ad-4bf2-bce2-41790e879e01.png)\n\n3. 配置完成后就可以进行上传了\n\n在上传区选择githubPuls就可以上传\n![image.png](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1628595615287-57877410-929b-4ae1-97b1-c3effc01f1f2.png)\n\n> 某分支和版本号大小不能超过50M会直接被jsDelivr屏蔽。所以单某个分支接近临界值，换分支继续就得了。\n\n> 参考博客：\n> [PicGo搭建github图床](https://jxiaow.gitee.io/posts/2513fba4/)\n> [jsdriver-github打造永久免费加速的图床](http://blog.wya1.com/article/636697030/details/21238)\n> [教你如何使用github+jsDelivr搭建免费图床](https://www.cnblogs.com/starry-skys/p/13905766.html)\n\n","tags":["图床"],"categories":["其他"]},{"title":"tensorflow中的asix理解","url":"/2020/12/13/2020-12-13-tensorflow中的asix理解/","content":"\n## 解释axis\n\n**axis是跟shape相关的**，比如说shape = [a, b, c, d]，那么`asix = 0`，就是指相关的操作是跟a这个维度有关的，`asix = 1`，就是指相关的操作是跟b这个维度有关，其他的就以此类推。其中有一个特殊的`asix = -1`，这是指跟d这个维度有关。(python中-1指最后一个元素)。\n<!--more-->\n下面让我们来看几个跟axis有关的函数\n\n## 例子\n\n### tf.reduce_mean\n```python\ntf.reduce_mean(input_tensor,axis=None,keepdims=None,\nname=None,reduction_indices=None,keep_dims=None)\n```\n\n这个函数经常用来求平均值，对于其中的axis参数就是指定对shape中哪一维进行求平均值（如果`axis=None`，那么就是对所有维度都求其平均值，最后返回一个single element）\n\n让我们来看一个例子：\n\n```python\na = tf.constant([[1., 1., 1.], [2., 2., 2.]])\nb = tf.reduce_mean(a, axis=None, keep_dims=True)\nc = tf.reduce_mean(a, axis=0, keep_dims=True)\nd = tf.reduce_meam(a, axis=1, keep_dims=True)\nwith tf.Session() as sess:\n    print(\"shape: \"+ str(a.shape))# shape: (2,3)\n    print(b.eval())# [[1.5]]\n    print(c.eval())# [[1.5 1.5 1.5]]\n    print(d.eval())# [[1.],[2.]]\n```\n\n通过上面的例子，可以看出当`axis=None`时，每一个维度依次都会求平均值；当`axis=0`时，就对行方向上的元素进行求平均值；当`axis=0`时，就对列方向上的元素进行求平均值。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/axis%E8%A7%A3%E9%87%8A_1.png\" style=\"zoom:50%;\" />\n\n### tf.split\n```python\ntf.split(\n    value, num_or_size_splits, axis=0, num=None, name='split'\n)\n```\n\n这个函数是用来对数据进行切割的，它会沿着第axis阶对value进行切割，切割成`num_or_size_splits`份。\n\n让我们来看个例子：\n\n```python\n# 'value' is a tensor with shape [2, 6]\n# Split 'value' into 3 tensors with sizes [1, 2, 3] along dimension 1\nvalue = tf.constant([[1,1,1,1,1,1],\n                    [2,2,2,2,2,2]])\nsplit0, split1, split2 = tf.split(value, num_or_size_splits=[1, 2, 3], axis=1)\nwith tf.Session() as sess:\n    print(split0.eval())\n    print(split1.eval())\n    print(split2.eval())\nprint(\"-------------\")\n# Split 'value' into 3 tensors along dimension 1\nsplit4, split5 = tf.split(value,num_or_size_splits=2, axis=0)\nwith tf.Session() as sess:\n    print(split4.eval())\n    print(split5.eval())\n# [[1]\n# [2]]\n# [[1 1]\n# [2 2]]\n# [[1 1 1]\n# [2 2 2]] \n# -------------\n# [[1 1 1 1 1 1]]\n# [[2 2 2 2 2 2]]\n```\n\n通过上面的例子可以看出，当`axis=0`时，就会沿着第0阶，也就是沿着纵方向将数据切割；当`axis=1`时，就会沿着第1阶，也就是沿着横方向将数据切割。\n\n## 总结\n\n综上，我们其实可以看出，axis在shape中代表哪一维度，那么就会对沿该维度方向上的数据进行求和、求平均和分割等操作。其中axis代表的维度大小会因操作而有所改变，但是其他维度的大小却并不会改变。","tags":["axis理解"],"categories":["tensorflow"]},{"title":"(计算机网络)TCP运输连接的建立和释放","url":"/2020/12/02/2020-12-2-计算机网络-tcp的连接和释放/","content":"## tcp的三次握手和四次握手\nTCP是面向连接的运输，这是因为在一个应用进程可以开始向另一个应用程序进程发送数据之前，这两个进程必须先互相“握手”，也就是互相发送某些特殊的报文段，以确认互相可以收到彼此发送的数据和建立确保数据传输的参数。\n<!--more-->\n\nTCP的这种“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，因为TCP协议旨在端系统中运行，而不再中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态，中间路由器对TCP连接完全视而不见，它们看到的是数据报而不是连接。另外TCP连接是**点对点**的，即单个发送方和单个接受方之间的连接。\n\n那么下面让我们看看TCP连接是如何建立的。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg\" style=\"zoom:67%;\" />\n\n发起连接的进程被称为**客户进程**，而另一个进程被称为**服务器进程**。假设主机A运行TCP客户进程，主机B运行TCP服务器进程，开始两端的TCP进程都处于CLOSRED状态。\n\n1. 主机B的TCP服务器进程先创建传输控制块TCB，此时处于LISTEN状态，等待客户的连接请求。\n2. 主机A的TCP客户进程也会先创建传输控制块TCB，当想要建立连接时，客户端的TCP先会向服务器端发送一个连接请求报文段(SYN 报文段)，这个报文段不包含应用层数据，但是会将报文段首部的标志位SYN=1，然后随机选择一个初始序号seq=x，此时TCP客户进程进入SYN-SENT状态。\n3. 主机B收到连接请求报文段，为该TCP连接分配TCP缓存和变量，并向客户进程发送允许连接报文段(SYNACK 报文段)，这个报文段也不包含应用层数据，但是会将报文段首部的标志位SYN=1，ACK=1，(确认号)ack=x+1,，然后选择一个初始序号seq = y，此时TCP服务器进程进入SYN-RCVD状态。\n4. 主机A收到允许连接请求报文段，为该TCP连接分配缓存和变量，并向服务器进程发送一个报文段，这个报文段是对服务器允许连接的报文段的确认。该报文段是可以携带应用层数据的，并且报文段首部的标志位SYN=0，ACK=1，ack=y+1，seq=x+1，此时TCP客户进程进入ESTABLISHED(已建立连接)状态。\n5. 服务器进程收到客户进程的确认报文段后，进入ESTABLISHED状态。\n\n至此两个主机的连接建立完成，客户和服务器主机就可以互相发送包括数据的报文段了，以后的每一个报文段的SYN都会被设置为0。\n\n天下无不散之宴席，TCP连接也是如此，参与一个连接的两个进程，任意一个都可以终止该连接，连接结束之后主机中参与连接的“资源”--缓存和变量都会释放。那再让我们看看TCP连接时如何释放的。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg\" style=\"zoom:80%;\" />\n\n此时客户进程和服务器进程都是处于ESTABLISHED状态。\n\n1. 当主机A的TCP客户进程要结束连接时，先向主机B的服务器进程发送连接释放报文段，这个报文段首部的标志位FIN=1，seq=u（这里的序号是已发送数据的最后一个字节的序号加一），并停止发送数据，此时客户进程进入FIN-WAIT-1状态。\n2. 当主机B的TCP服务器进程收到连接释放报文段后，立即发送确认报文段，这个报文段首部的标志位ACK=1，ack=u+1，seq=v，但是可以继续发送未发送完的数据，此时服务器进程进入CLOSE-WAIT状态。\n3. 当主机A的TCP客户进程收到了确认报文段后，进入FIN-WAIT-2状态，等待主机B发送的连接释放报文段。\n4. 当主机B没有要向A发送的数据后，其服务器进程就会通知TCP发送连接释放报文段，这个报文段首部的标志位FIN=1，ACK=1，seq=w，ack=u+1,这时服务器进程进入LAST-ACK状态。\n5. 当主机A收到来自主机B的连接释放报文段后，理解发送确认报文段，这个报文段首部的标志位ACK=1，seq=u+1，ack=w+1，此时TCP客户进程进入TIME-WAIT状态，等待2MSL的时间后进入CLOSED状态，如果再次收到来自主机B的连接释放报文段，重新发送确认报文段，然后再等待2MSL，注意在TIME-WAIT状态时，连接并没有释放掉。\n6. 当主机B收到主机A的确认报文段后，立即进入CLOSED状态。如果超时则重新发送连接释放报文段。\n\n至此TCP连接的释放也就完成了，在整个TCP连接的建立和释放中，连接建立时一共发送了三个报文段，因此被称为“三次握手”，而连接释放时一共发送了四个报文段，因而被称为“四次握手”。\n\n有关序号(seq)和确认号(ack)：\n\n- **序号**是TCP报文段的一个字段，TCP把数据看成无结构、有序的字节流，而序号就是建立在这样的字节流上的，不是建立在传送的报文段的序列上的。因此一个报文段的序号就是该报文段首字节的字节流编号。举一个例子，假如数据流是由一个500 000字节的文件组成，其MSS的大小为1000字节，数据流的首字节的标号为0，那么TCP为该数据流构建500个报文段，其中第一个报文段的序号为0，第二个报文段的序号为1000，以此类推。\n- **确认号**是也是TCP报文段的一个字段，TCP是全双工的，当主机A给主机B发送数据的同时，也可能会收到来自主机B的数据，**主机A填入报文段中的确认号是希望从主机B收到下一个字节的序号。**假设主机A收到了来自主机B的编号为0~535的所有字节，同时主机A有准备给主机B发送一个报文段，那么就会在给主机B发送的这个报文段中填上确认号534。\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E6%95%B0%E6%8D%AE%E6%B5%81.jpg\" style=\"zoom:67%;\" />\n\n> 文章参考自《计算机网络》第七版--谢希仁——5.9.2 TCP连接释放\n>                     《计算机网络：自顶向下方法》7th——3.5.6TCP连接管理","tags":["tcp"],"categories":["计算机网络"]},{"title":"有关二项分布和二项式系数","url":"/2020/08/31/2020-8-31-Binomial/","content":"`来源`：algorithms4一书中的**Exercises1.1.27**\n\n## 二项式系数（binomail coeff）\n\n### 基本概念\n\n​        在数学上，二项式系数是二项式定理中各项的系数。一般而言吗，二项式系数有两个非负整数`n`和`k`为参数决定，写作 $n \\choose k$，定义为$(1+x)^{n}$的 多项式展开式中，$x^{k}$项的系数，因此一定是非负整数。如果将二项式系数$\\left(\\begin{array}{l}n \\\\ 0\\end{array}\\right),\\left(\\begin{array}{l}n \\\\ 1\\end{array}\\right), \\ldots,\\left(\\begin{array}{l}n \\\\ n\\end{array}\\right)$写成一行，再依照$n=0,1,2, \\ldots$顺序由上往下排列，则构成**帕斯卡三角形**或者**杨辉三角**。\n\n<!--more-->\n\n-----------来源自[维基百科]([https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%BC%8F%E4%BF%82%E6%95%B8](https://zh.wikipedia.org/wiki/二項式係數))\n\n### 递推公式\n\n$$\n\\begin{array}{l}\nC(n, k)=C(n-1, k-1)+C(n-1, k) \\\\\nC(n, 0)=C(n, n)=1\n\\end{array}\n$$\n\n根据上面的递推公式，发现可以把原问题分解成两个相同的子问题，并且结合初始条件后，可以使用递归的方法求解二项式系数。\n\n> **递归**是指一种通过重复将问题分解为同类的子问题而解决问题的方法。在递归代码中最重要的两个点：递推公式和结束条件。递推公式用于将问题分解为子问题，结束条件是最简子问题的答案。\n\n### 代码实现\n\n- **Optimal Substructure** (Following is a simple recursive implementation that simply follows the recursive structure mentioned above.)\n\n  ```java\n  // Returns value of Binomial \n  \t// Coefficient C(n, k) \n  \tstatic int binomialCoeff(int n, int k) \n  \t{ \n  \t\n  \t\t// Base Cases \n  \t\tif (k == 0 || k == n) \n  \t\t\treturn 1; \n  \t\t\n  \t\t// Recur \n  \t\treturn binomialCoeff(n - 1, k - 1) + \n  \t\t\t\t\tbinomialCoeff(n - 1, k); \n  \t} \n  \t\n  ```\n\n  \n\n- **Overlapping Subproblems** (DP based implementation)\n\n  ```java\n  // Returns value of Binomial Coefficient C(n, k) \n      static int binomialCoeff(int n, int k) \n      { \n      int C[][] = new int[n+1][k+1]; \n      int i, j; \n        \n          // Calculate  value of Binomial Coefficient in bottom up manner \n      for (i = 0; i <= n; i++) \n      { \n          for (j = 0; j <= min(i, k); j++) \n          { \n              // Base Cases \n              if (j == 0 || j == i) \n                  C[i][j] = 1; \n         \n              // Calculate value using previously stored values \n              else\n                  C[i][j] = C[i-1][j-1] + C[i-1][j]; \n            } \n       } \n         \n      return C[n][k]; \n      } \n    \n      // A utility function to return minimum of two integers \n      static int min(int a, int b) \n      { \n      return (a<b)? a: b;  \n      } \n  ```\n  **对于基于DP实现的方法**：为什么能使用DP方法实现呢？因为我们发现实际上在递归调用的时候，很多函数是会被重复调用的（如下图），但是递归时并不会储存前面已经计算出的结果，而是会重新计算，这样的情况怎么才能避免呢？那只要将已经计算过的值储存下来，以后再使用的时候就不用再计算了。而二项式系数这个问题具有动态规划的两个特点，分别就是[Optimal substructure](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)和[Overlapping subproblem](https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/)，因此我们可以使用DP方法来实现计算二项式系数这个问题。<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/1381c0000d9140e5bc0f9\" alt=\"recursion tree\" style=\"zoom: 67%;\" />\n\n  **关于代码**：为什么数组大小是`int[n+1][k+1]`？因为要计算`C[n][k]`需要从最底层的`C[0][0]`一层一层计算到`C[n][k]`，而每一层所要知道的值是`C[*][j]`且`j<=min(i,k)`，所以我们所需的二维数组大小至少应该是N行K列，才足以储存我们计算得到的值。为什么第二层循环中`j<=min(i,k)`而不是`j<=k`？首先`j<=k`我们应该都是可以理解的，因为要遍历整个二维数组，但是对于二项式系数还有一个限制条件就是`0<=j<=i`（想一想杨辉三角其实很容易就得出），而i与k得大小不定的，所以我们要取最小的一个。\n\n> 参考自 GeeksforGeeks---[Binomial Coefficient](https://www.geeksforgeeks.org/binomial-coefficient-dp-9/)\n>\n\n\n\n## 二项分布（Binomial distribution）\n\n### 基本概念\n\n​        二项分布是*n*个独立的成功/失败实验中成功的次数的离散概率分布，其中每次试验的成功概率为*p*。一般地，如果随机变量*X*服从参数为n和*p*的二项分布，我们记$X \\sim b(n, p)$或$X \\sim B(n, p)$。n次试验中正好得到k次成功的概率由概率质量函数给出：\n$$\nf(k, n, p)=\\operatorname{Pr}(X=k)=\\left(\\begin{array}{l}\nn \\\\\nk\n\\end{array}\\right) p^{k}(1-p)^{n-k}\n$$\n对于$k=0,1,2, \\ldots, n$，其中$\\left(\\begin{array}{l}n \\\\ k\\end{array}\\right)$是二项式系数，又记为$C(n, k)$，$C_{n}^{k}$\n\n-----------来源自[维基百科]([https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%88%86%E4%BD%88](https://zh.wikipedia.org/wiki/二項分佈))\n\n### 递归公式\n\n$$\n\\begin{aligned}\nC_{n}^{k}p^{k}(1-p)^{n-k}&=(C_{n-1}^{k}+C_{n-1}^{k-1})p^{k}(1-p)^{n-k}\\\\\n&=C_{n-1}^{k}p^{k}(1-p)^{n-k}+C_{n-1}^{k-1}p^{k}(1-p)^{n-k}\\\\\n&=(1-p)C_{n-1}^{k}p^{k}(1-p)^{n-k-1}+pC_{n-1}^{k-1}p^{k-1}(1-p)^{n-k}\\\\\nC_{0}^{0}p^{0}(1-p)^{0}=1\n\\end{aligned}\n$$\n\n### 代码实现\n\n- **recursive implementation** \n\n  ```java\n  public static double binomial1(int N, int k, double p) {\n          \n          if (N == 0 && k == 0) return 1.0; \n          if (N < 0 || k < 0) return 0.0;\n          \n          return (1.0 - p) * binomial1(N - 1, k, p) + p * binomial1(N - 1, k - 1, p);\n      }\n  ```\n\n  **关于代码**：对于计算二项分布的结束条件为什么和计算二项式系数不同？因为二项分布返回的分布的值，不仅仅是二项式系数，而计算二项式系数时的结束条件，是我们已经清楚地知道当`k == 0 || k == n`二项式系数的值肯定是1，但是计算二项分布时，我们知道的唯一条件就是当`N == 0 && k == 0`分布的值为1，而当`N < 0 || k < 0`时连二项式系数都不存在，那么返回的分布的值为0是显而易见的。虽然计算二项分布时不能用计算二项式系数的结束条件，但是反过来，计算二项式系数时却可以使用计算二项分布的结束条件。由此可见，`if (N == 0 && k == 0) return 1.0;`和`if (N < 0 || k < 0) return 0.0;`这两个条件是更为一般的条件。\n\n- **DP based implementation**\n\n  ```java\n  \tstatic double binomial2(int N, int k, double p) {\n          double[][] b = new double[N+1][k+1];\n  \n          // base cases\n          for (int i = 0; i <= N; i++)\n              b[i][0] = Math.pow(1.0 - p, i);\n          b[0][0] = 1.0;\n  \n          // recursive formula\n          for (int i = 1; i <= N; i++) {\n              for (int j = 1; j <= min(i, k); j++) {\n                  b[i][j] = p * b[i-1][j-1] + (1.0 - p) *b[i-1][j];\n              }\n          }\n          \n          return b[N][k];\n      }\n  \n      public static int min(int a, int b){\n          return (a<b)?a:b;\n      }\n  ```\n\n  **关于代码**：二项分布同样是可以用动态规划的方法解决，主要就是使用数组将计算过的分布值储存下来，以避免重复计算。因为数组的下标是没有负的，我们就失去了一个在递归方法中的一个条件，但是我们明确地知道当`k = 0`时分布的值为`Math.pow(1.0 - p, i)`，因此可以提前计算出这些分布值，再由已知分布值计算其他的分布值。那有人就要问了，为什么我们不用计算出`k = n`时分布的值`Math.pow(p, i)`？举个例子，当我们要求`b[5][5]`时，我们需要知道`b[4][4]`和`b[4][5]`，`b[4][5]`实际上是不存在的，所以它在数组中的值是0，那我们就知道了`b[5][5] = p*b[4][4]`，而`b[4][4]`当然可以`b[3][3]`求得，以此类推，`b[5][5]`也就可以求出了。还有我们能用到`b[i][i]`的时候也很少，所以没有必要取单独计算。\n\n","tags":["二项式"],"categories":["Math"]},{"title":"问题：多段图求s到t的最小成本路径","url":"/2020/08/11/2020-4-24-多段图/","content":"\n## 什么是多端图\n\n- 多段图是一个带权有向图并且无环\n- 有且仅有一个起始点（原点source）和一个终止节点（汇点target）\n- 它有n个阶段，每个阶段由特定的几个结点构成\n- 每个结点的所有结点都只能指向下一个相邻的阶段，阶段之间不能越界\n<!-- more -->\n### 多段图\n\n<img src=\"https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/%E5%A4%9A%E6%AE%B5%E5%9B%BE.jpg\" style=\"zoom:80%;\" />\n\n> 图中的节点被划分程k≥2个不相交的集合Vi，1≤i≤k，其中V1和Vk分别只有一个结点 s（源点）和t（汇点）。\n\n``这个问题用动态规划的方法解决，分别有向前处理和向后处理两种思路``\n\n#### 数据结构\n\n- cost数组：该数组用于记录以某个结点为起点，到终点t的最短路径长度值。\n- d数组：该数组用于记录最短路径中出现的所有结点，下标表示结点的编号，数组值表示i的后继结点标号。\n  \n##### 多段图向前处理的算法\n\n>流程\n\n1. 从最后一个结点（汇点）开始，从后向前，依次计算每个结点的cost值和d值。\n2. 直到计算完第一个结点（源点）后，即可根据d数组得到最短路径。\n\n>思路：   \n>从最后一层的汇点开始，找当前这一层每个结点到汇点的最短路径，并且使用cost数组储存最短路径长度值，以便让上一层的结点计算最短路径长度值时不在重复计算，同时使用d数组储存该结点到下一层最短路径上的那个结点。这就体现了动态规划的思想，使用空间换取时间，储存现阶段的值，让下一阶段不在重复计算。   \n> **结合下面的算法执行过程更容易理解**\n\n>算法执行过程：\n>当前结点i到汇点t的最短路径长度cost[i] = min{结点i到下一层结点j的路径长度 + 下一层节点j到汇点t的最短路径长度cost[j]}(min是取最小的一个)\n\n- V5：cost[12] = 0\n- V4：cost[11] = min{ c(11,12)+cost[12] } = min{1 + 0} = 1 , **d[11] = 12**\n- V4：cost[10] = min{ c(10,12)+cost[12] } = min{2 + 0} = 2 , **d[10] = 12**\n- V4：cost[9] = min{ c(9,12)+cost[12] } = min{4 + 0} = 4 , **d[9] = 12**\n- V3：cost[8] = min{ c(8,11)+cost[11], c(8,10)+cost[10]} = min{7,7} = 7 , **d[8] = 10**\n- V3：cost[7] = min{ c(7,10)+cost[10], c(7,9)+cost[9]} = min{5,8} = 5 , **d[7] = 10**\n- V3：cost[6] = min{ c(6,10)+cost[10], c(6,9)+cost[9]} = min{7,10} = 7 , **d[6] = 10**\n- V2：cost[5] = min{ c(5,8)+cost[8], c(5,7)+cost[7]} = min{15,16} = 15 , **d[5] = 8**\n- V2：cost[4] = min{ c(4,8)+cost[8] } = min{11+7} = 18 , **d[4] = 8**\n- V2：cost[3] = min{ c(3,7)+cost[7], c(3,6)+cost[6]} = min{12,9} = 9 , **d[3] = 6**\n- V2：cost[2] = min{ c(2,8)+cost[8], c(2,7)+cost[7], c(2,6)+cost[6]} = min{8,7,11} = 7 , **d[2] = 7**\n- V1：cost[1] = min{ c(1,5)+cost[5], c(1,4)+cost[4], c(1,3)+cost[3], c(1,2)+cost[2]} = min{17,22,16,15} = 15 , **d[1] = 2**\n\n>根据上面的计算我们可以得出从源点s到汇点t的最短路径长度为15，同时可以通过数组d[1]依次向后推得到最短路径1->2->7->10->12;\n\n![](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/QQ%E5%9B%BE%E7%89%8720200424202235.png)\n\n##### 算法描述\n\n```c\ncost[n] = 0;\nfor i=n-1 downto 1 do\n{\n    寻找结点r,满足<i,r>∈E(有向边)且使c(i,r) + cost[r]最小\n    cost[i] = c(i,r) + cost[r];\n    d[i] = r;\n}\n//根据数组d求最短路径\np[1] = 1; p[k] = n;\nfor i=2 to k-1 do\np[i]=d[p[i-1]];\nend\n```\n\n------\n\n**多段图向后处理的算法其实和向前处理的算法思路基本上是一致的,有关具体的代码以后会补充上。**\n\n注:本文章参考了多篇文章和老师上课所讲的笔记,我都会把链接发在下面,有需要的人可以看看。\n>[参考博客1](https://blog.csdn.net/u010425776/article/details/70053196) \n>[参考博客2](https://blog.csdn.net/ncepuzhuang/article/details/8923790)\n>[老师的笔记](https://ae01.alicdn.com/kf/U74d5dbb2143b436db8df7f1d2c37678ck.jpg)","tags":["动态规划"],"categories":["算法"]},{"title":"使用Matlab解决简单的线性规划问题","url":"/2020/08/11/2020-3-7-linearPrograming/","content":"\n> 如果你还没有Matlab，那么可以在[这里](https://www.macxin.com/archives/10739.html)安装！！！\n\n## 什么是线性规划？\n\n**线性规划**是一个在数学模型中能够得到最好结果的方法，而这个数学模型是用线性关系表示的。更正式地说，线性规化是一种优化线性目标函数的技术，这种技术受线性等式和线性不等式的约束。\n<!-- more -->\n## 线性规划能用来做什么?\n\n在运筹学的领域，线性规划使用来得到最优解的。它可以让我们在一个问题的所有限制或约束条件中找到最好、最经济的解决办法。\n\n### 问题引入\n\n> 某机床生产甲、乙两种机床，每台销售后的利润分别为4千元、3千元。生产甲机床需要A，B机器加工，加工时间分别为每台2h和1h；生产乙机床需要A,B,C三种机器加工加工时间为每台各1h。若每天可用于加工的机器时数分别为A机器10h、B机器8h、C机器7h，问该生产甲、乙机床各几台，才能是总利润最大？\n\n根据问题，我们假设需要生产甲机床$x_1$台，乙机床$x_2$台才能使利润最大。\n> max z = 4$x_{1}$ + 3$x_2$  \n> 2$x_1$ + $x_2$ $\\leq$ 10  \n> $x_1$ + $x_2$  $\\leq$ 8  \n> $x_1$ $\\leq$ 7  \n> $x_1$ ,$x_2$ $\\geq$ 0\n\n以上就是根据题意得出的目标函数和约束条件。  \n\n**线性规划的图解法**  \n图解法可以说是使得问题更加的清晰和明了，正如数学教授华罗庚说的“数无形时少直觉，形少数时难入微”，对于简单的线性规划问题，图解法是一种好的解决办法。\n\n![](https://cdn.jsdelivr.net/gh/JxuFang/image@master/blog/picture1.png)\n``给定一个固定z值，就会有一条相应的目标直线，而我们需要的是最大利润，那么就是希望z的值最大，当目标直线和可行域（阴影部分）某个点相交时使得z的值最大，那么这个点就是我们想要得到的可行解(2,6)``\n\n#### 下面就是我们今天要说的 *使用Matlab来求解线性规划问题*\n\n**linprog**是我们在matlab中解决线性规划问题所要用的函数，其中有几个重要的参数：\n>**A** 是一个线性不等式约束的M$\\times$N系数矩阵，其中M是不等式的数量，N是自变量的数量。\n>\n>**b** 是一个具有M个元素的列向量\n>\n>这样的不等式应该是 A*x $\\leq$ b的形式。  \n>For example：  \n>$x_1$ + 2$x_2$ $\\leq$ 10  \n>3$x_1$ + 4$x_2$ $\\leq$ 20  \n>5$x_1$ + 6$x_2$ $\\leq$ 30  \n>$\\Downarrow$  \n>A = [1,2;3,4;5,6];  \n>b = [10;20;30];\n>\n>**Aeq** 是一个线性等式约束的M$\\times$N系数矩阵，其中M是不等式的数量，N是自变量>的数量。  \n>**beq** 是一个具有M个元素的列向量  \n>For example：  \n>$x_1$ + 2$x_2$ +3$x_3$ = 10  \n>2$x_1$ + 4$x_2$ +$x_3$= 20  \n>$\\Downarrow$  \n>Aeq = [1,2,3;2,4,1];  \n>beq = [10;20];  \n>\n>**lb** 是变量的下限（Lower bounds）  \n>**ub** 是变量的上限（upper bounds）  \n>For example：  \n>-1 $\\leq$ $x_1$ $\\leq$ 1.5  \n>-0.5 $\\leq$ $x_2$ $\\leq$ 1.25  \n>$\\Downarrow$  \n>lb = [-1,-0.5];  \n>ub = [1.5,1.25];  \n>其中**无穷的表示方法**为 **inf**  \n>**f** 是目标函数的系数向量  \nExample：f = [1,3,5,-6];\n\nlinprog的一些语法（Syntax）:\n\n1. x = linprog(f,A,b)\n2. x = linprog(f,A,b,Aeq,beq)\n3. x = linprog(f,A,b,Aeq,beq,lb,ub)\n\n**线性规划问题标准的矩阵表达形式为:**\n> min $C^T$X\n> AX = b\n> X $\\geq$ 0\n\n**Matlab代码块：**\n\n```matlab\n>> A = [2,1;1,1];\n>> b = [10;8];\n>> Aeq = [];\n>> beq = [];\n>> lb = [0,0];\n>> ub = [7,inf];\n>> f = [-4,-3];\n>> x = linprog(f,A,b,Aeq,beq,lb,ub)\n\nOptimal solution found.\n\n\nx =\n\n     2\n     6\n\n```\n\n**注意**: 目标函数根据标准形式应该由最大（max）通过目标函数的标准化化为最小（min），f = [-4,-3]而不是[4,3]. 如果没有不等式A*x $\\leq$ b的存在，则令A = [],b = [];若没有等式约束，则令Aeq = [],beq = []。\n\n***\n**以上就是我使用matlab解决线性规划问题的方法，当然我并没有将Matlab中求解线性规划问题的所有东西都讲到，我在这只是起到一个抛砖引玉的作用，如果想要学习更多的方法请你也来动动手，更加深入的学习吧！！**\n\n[Matlab中文文档](https://ww2.mathworks.cn/help/matlab/ref/doc.html)中有更多关于Matlab的使用方法。\n","tags":["matlab"],"categories":["Math"]}]